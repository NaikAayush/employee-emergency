{"version":3,"sources":["./node_modules/ml-matrix/src/matrix.js","./src/app/employee/views/tabs/employee-map/employee-map.page.ts","./node_modules/ml-curve-fitting/src/algebra.js","./src/app/employee/views/tabs/employee-map/employee-map-routing.module.ts","./node_modules/ml-stat/array.js","./node_modules/ml-matrix/src/dc/util.js","./node_modules/ml-matrix/src/util.js","./node_modules/ml-matrix/src/views/flipRow.js","./node_modules/ml-matrix/src/symbol-species.js","./node_modules/ml-matrix/src/dc/lu.js","./src/app/employee/views/tabs/employee-map/employee-map.page.scss","./node_modules/ml-matrix/src/decompositions.js","./src/app/employee/views/tabs/employee-map/employee-map.module.ts","./node_modules/ml-matrix/src/views/flipColumn.js","./node_modules/ml-matrix/src/dc/evd.js","./node_modules/ml-array-utils/src/snv.js","./src/app/employee/services/trilateration/trilateration.service.ts","./node_modules/ml-matrix/src/dc/svd.js","./node_modules/ml-array-utils/src/ArrayUtils.js","./src/app/employee/views/tabs/employee-map/employee-map.page.html","./node_modules/ml-matrix/src/views/transpose.js","./node_modules/ml-matrix/src/views/selection.js","./node_modules/ml-matrix/src/views/base.js","./node_modules/ml-stat/matrix.js","./node_modules/ml-stat/index.js","./node_modules/trilat/index.js","./node_modules/ml-matrix/src/abstractMatrix.js","./node_modules/ml-matrix/src/views/row.js","./node_modules/ml-curve-fitting/src/index.js","./node_modules/ml-matrix/src/views/column.js","./node_modules/ml-matrix/src/index.js","./node_modules/ml-matrix/src/dc/cholesky.js","./node_modules/ml-matrix/src/dc/qr.js","./node_modules/ml-curve-fitting/src/LM.js","./node_modules/ml-array-utils/src/index.js","./node_modules/ml-array-utils/src/getEquallySpaced.js","./node_modules/ml-matrix/src/views/sub.js"],"names":[],"mappings":";;;;;;;;;;AAAa;;AAEb,mBAAO,CAAC,8BAAkB;AAC1B,qBAAqB,mBAAO,CAAC,8BAAkB;AAC/C,WAAW,mBAAO,CAAC,oBAAQ;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,iDAAiD;AAC1D;AACA;AACA,2BAA2B,WAAW;AACtC;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS,iCAAiC;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,yBAAyB,iBAAiB;AAC1C,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,aAAa;AAC5B,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,aAAa;AAC5B,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5IoE;AACK;AAC/B;AAID;AAID;AAIM;AAId;AAIC;AAC0B;AAEpB;AAI8D;AACZ;AAEM;IAOlF,eAAe,SAAf,eAAe;IAmE1B,YACU,SAA2B,EAC3B,OAA2B;IACnC,8CAA8C;IAC7B,OAAgB,EAChB,QAAkB,EAC3B,SAA4B,EAC5B,WA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YAGX,2EAAY;YAIZ,sFAAiB;YAiBV,mHAAoB;YACpB,uGAAgB;YAEhB,6GAAkB;;AAOd,eAAe;IAL3B,+DAAS,CAAC;QACT,QAAQ,EAAE,kBAAkB;QAC5B,oFAAuC;;KAExC,CAAC;GACW,eAAe,CAqf3B;AArf2B;;;;;;;;;;;;;ACvC5B;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,aAAa,mBAAO,CAAC,uBAAW;;AAEhC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,uBAAuB,QAAQ;AAC/B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,uBAAuB,QAAQ;AAC/B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC3PyC;AACc;AAED;AAEtD,MAAM,MAAM,GAAW;IACrB;QACE,IAAI,EAAE,EAAE;QACR,SAAS,EAAE,kEAAe;KAC3B;CACF,CAAC;IAMW,4BAA4B,SAA5B,4BAA4B;CAAG;AAA/B,4BAA4B;IAJxC,8DAAQ,CAAC;QACR,OAAO,EAAE,CAAC,4DAAY,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;QACxC,OAAO,EAAE,CAAC,4DAAY,CAAC;KACxB,CAAC;GACW,4BAA4B,CAAG;AAAH;;;;;;;;;;;;;AChB5B;;AAEb;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,aAAa;AACb;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,QAAQ,4CAA4C;AAC/D,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,OAAO;AAC1B;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,QAAQ,4CAA4C;AAC/D,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,YAAY;AACZ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,OAAO;AAC1B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,OAAO;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;;;;;;;;;;;;;AC9da;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA,uBAAuB,aAAa;AACpC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpCa;;AAEb,aAAa,mBAAO,CAAC,sBAAU;;AAE/B;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB,YAAY;AACZ,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB,YAAY;AACZ,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,iBAAiB;AACpC,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,iBAAiB;AACpC,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,iBAAiB;AACpC,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7Ia;;AAEb,eAAe,mBAAO,CAAC,oBAAQ;;AAE/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACnBa;;AAEb;AACA;AACA;;;;;;;;;;;;;ACJa;;AAEb,aAAa,mBAAO,CAAC,uBAAW;;AAEhC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,UAAU;AACzB;AACA;;AAEA;;AAEA,eAAe,aAAa;;AAE5B,mBAAmB,UAAU;AAC7B;AACA;;AAEA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,aAAa;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC,2BAA2B,aAAa;AACxC;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC,2BAA2B,aAAa;AACxC;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,aAAa;AAChC,2BAA2B,aAAa;AACxC,2BAA2B,WAAW;AACtC;AACA;AACA;AACA;AACA,6BAA6B,QAAQ;AACrC,uBAAuB,WAAW;AAClC;AACA;AACA,uBAAuB,OAAO;AAC9B,2BAA2B,WAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC7KA;AAAe,6GAA8C,2HAA2H,E;;;;;;;;;;;;ACA3K;;AAEb,aAAa,mBAAO,CAAC,sBAAU;;AAE/B,iCAAiC,mBAAO,CAAC,sBAAU;AACnD,8BAA8B,mBAAO,CAAC,sBAAU;AAChD,sBAAsB,mBAAO,CAAC,qBAAS;AACvC,sBAAsB,mBAAO,CAAC,qBAAS;AACvC,4BAA4B,mBAAO,CAAC,2BAAe;;AAEnD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC7DyC;AACM;AACF;AAEA;AAEgC;AAEvB;IAWzC,qBAAqB,SAArB,qBAAqB;CAAG;AAAxB,qBAAqB;IATjC,8DAAQ,CAAC;QACR,OAAO,EAAE;YACP,4DAAY;YACZ,0DAAW;YACX,0DAAW;YACX,yFAA4B;SAC7B;QACD,YAAY,EAAE,CAAC,kEAAe,CAAC;KAChC,CAAC;GACW,qBAAqB,CAAG;AAAH;;;;;;;;;;;;;ACnBrB;;AAEb,eAAe,mBAAO,CAAC,oBAAQ;;AAE/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACnBa;;AAEb,eAAe,mBAAO,CAAC,uBAAW;AAClC,aAAa,mBAAO,CAAC,oBAAQ;AAC7B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,mBAAmB,OAAO;AAC1B,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,mBAAmB,OAAO;AAC1B,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,eAAe,OAAO;AACtB;AACA;;AAEA,mBAAmB,OAAO;AAC1B;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;;AAEA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA,SAAS;AACT,uBAAuB,OAAO;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;;AAEA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;;AAEA;AACA,uBAAuB,OAAO;AAC9B;AACA;;AAEA,uBAAuB,OAAO;AAC9B;AACA;AACA,2BAA2B,YAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;;AAEA,uBAAuB,QAAQ;AAC/B;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;AACA;;AAEA,eAAe,OAAO;AACtB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,WAAW;AAC1B;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,eAAe;AACpC;AACA,mBAAmB,WAAW;AAC9B;AACA;;AAEA;AACA;AACA,0BAA0B,QAAQ;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,OAAO;AAC9B;AACA,8BAA8B,QAAQ;AACtC;AACA;;AAEA;AACA,2BAA2B,WAAW;AACtC;AACA;AACA;;AAEA,uBAAuB,WAAW;AAClC;AACA,8BAA8B,QAAQ;AACtC;AACA;;AAEA;AACA,2BAA2B,WAAW;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,eAAe,OAAO;AACtB,mBAAmB,OAAO;AAC1B;AACA;AACA;;AAEA,sBAAsB,cAAc;AACpC;AACA,2BAA2B,WAAW;AACtC;AACA;;AAEA,uBAAuB,WAAW;AAClC;AACA,2BAA2B,WAAW;AACtC;AACA;;AAEA;AACA,2BAA2B,WAAW;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA,oCAAoC,QAAQ;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;;AAEA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;;AAEA,6BAA6B,WAAW;AACxC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+BAA+B,yBAAyB;AACxD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iCAAiC,WAAW;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB,QAAQ;AAC5B;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;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AACtC;AACA;AACA,+BAA+B,OAAO;AACtC,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,QAAQ;AAC7B,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA,+BAA+B,QAAQ;AACvC;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA,2BAA2B,WAAW;AACtC;AACA;AACA,aAAa;AACb,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,QAAQ;AAC/B;AACA,+BAA+B,OAAO;AACtC;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,WAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,WAAW;AAC9B;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,WAAW;AAC9B,uBAAuB,WAAW;AAClC;AACA,2BAA2B,WAAW;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,WAAW;AAC9B,uBAAuB,WAAW;AAClC;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,WAAW;AAC9B,uBAAuB,WAAW;AAClC;AACA,2BAA2B,WAAW;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACjgBa;;AAEb,aAAa,mBAAO,CAAC,qBAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,kBAAkB;AACpC;AACA,sBAAsB,gBAAgB;AACtC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,6BAA6B;AAChD;AACA;;AAEA,cAAc,kBAAkB;AAChC,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;;AAEA,eAAe,mBAAmB;AAClC,sBAAsB,sBAAsB;AAC5C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,gBAAgB;AACnC;AACA,uBAAuB,2BAA2B;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/NA;AAAe,00BAA2wB,GAAG,qDAAqD,E;;;;;;;;;;;;ACAr0B;;AAEb,eAAe,mBAAO,CAAC,oBAAQ;;AAE/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACnBa;;AAEb,eAAe,mBAAO,CAAC,oBAAQ;AAC/B,WAAW,mBAAO,CAAC,qBAAS;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACvBa;;AAEb,qBAAqB,mBAAO,CAAC,+BAAmB;AAChD,aAAa,mBAAO,CAAC,uBAAW;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AClBa;;AAEb,gBAAgB,mBAAO,CAAC,qBAAS;;AAEjC;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,mBAAmB;AACtC,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,mBAAmB;AACtC,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,UAAU;AAC7B,uBAAuB,UAAU;AACjC;AACA;AACA;AACA,KAAK;AACL;AACA,mBAAmB,UAAU;AAC7B;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA,KAAK;AACL;AACA,mBAAmB,UAAU;AAC7B;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,UAAU;AAC7B,uBAAuB,UAAU;AACjC;AACA;AACA;AACA,KAAK;AACL;AACA,mBAAmB,UAAU;AAC7B;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA,KAAK;AACL;AACA,mBAAmB,UAAU;AAC7B;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,UAAU;AAC7B;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,UAAU;AAC7B;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;;AAEA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,OAAO;AAC1B;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,OAAO;AAC1B;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA,mBAAmB,UAAU;AAC7B,uBAAuB,UAAU;AACjC;AACA,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA,mBAAmB,UAAU;AAC7B,uBAAuB,UAAU;AACjC;AACA,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,UAAU;AACzB;AACA;AACA,eAAe,UAAU;AACzB,mBAAmB,UAAU;AAC7B;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;;AAEA,eAAe,OAAO;AACtB;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;;AAEA,eAAe,OAAO;AACtB;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,UAAU;AAC7B;AACA;;AAEA,uBAAuB,UAAU;AACjC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA,KAAK;AACL;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA,mBAAmB,UAAU;AAC7B,uBAAuB,UAAU;AACjC;AACA,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA,mBAAmB,UAAU;AAC7B,uBAAuB,UAAU;AACjC;AACA,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;;;;;;;;;;;;AClmBa;;AAEb,gBAAgB,mBAAO,CAAC,qBAAS;AACjC,iBA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AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,2BAA2B,eAAe;AAC1C,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,2BAA2B,eAAe;AAC1C,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,2BAA2B,eAAe;AAC1C,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA;AACA;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA;AACA;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,2BAA2B,eAAe;AAC1C,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA,2BAA2B,eAAe;AAC1C,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,2BAA2B,OAAO;AAClC,+BAA+B,OAAO;AACtC;AACA;;AAEA,+BAA+B,OAAO;AACtC;AACA,+BAA+B,OAAO;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,GAAG,KAAK,GAAG,OAAO,GAAG,KAAK,GAAG;AACzE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,eAAe;AAC1C,+DAA+D,SAAS;AACxE;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,oBAAoB,OAAO;AAC3B;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,OAAO;AAClC,+BAA+B,OAAO;AACtC,mCAAmC,OAAO;AAC1C,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,2BAA2B,eAAe;AAC1C,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,SAAS;AAC5B,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,SAAS;AAC5B,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA;AACA;AACA,kCAAkC,aAAa;AAC/C,yCAAyC,gBAAgB;AACzD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,MAAM;AACzB,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,oBAAoB;AAC/C,yCAAyC,gBAAgB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,MAAM;AACzB,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,oBAAoB;AAC/C,sCAAsC,aAAa;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,sBAAsB;AACzC,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C,+BAA+B,oBAAoB;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,cAAc;AACjC,mBAAmB,cAAc;AACjC,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA,2BAA2B,wBAAwB;AACnD;AACA,+BAA+B,2BAA2B;AAC1D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC,mBAAmB,cAAc;AACjC,oBAAoB;AACpB;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA,yDAAyD,oBAAoB;;AAE7E;AACA;AACA;;AAEA,2BAA2B,cAAc;AACzC;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,mBAAmB,eAAe;AAClC,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,mBAAmB,eAAe;AAClC,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,mBAAmB,eAAe;AAClC,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;;;AAGA;AACA;AACA,mBAAmB,eAAe;AAClC,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,oEAAoE,mCAAmC;AACvG,2EAA2E,yCAAyC;AACpH,2EAA2E,yCAAyC;AACpH,kEAAkE,kBAAkB;AACpF,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,oEAAoE,mCAAmC;AACvG,kEAAkE,gBAAgB;AAClF,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,sBAAsB;AACzC,4BAA4B,EAAE;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,sFAAsF,mCAAmC;AACzH,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACzxDa;;AAEb,eAAe,mBAAO,CAAC,oBAAQ;;AAE/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACpBa;;AAEb,iBAAiB,mBAAO,CAAC,kBAAM;AAC/B,wBAAwB,mBAAO,CAAC,uBAAW;AAC3C,gCAAgC,mBAAO,CAAC,uBAAW;;;;;;;;;;;;;ACJtC;;AAEb,eAAe,mBAAO,CAAC,oBAAQ;;AAE/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACpBa;;AAEb,iBAAiB,mBAAO,CAAC,sBAAU;AACnC,oDAAoD,mBAAO,CAAC,8BAAkB;;;;;;;;;;;;;ACHjE;;AAEb,aAAa,mBAAO,CAAC,uBAAW;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,eAAe,eAAe;AAC9B;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,eAAe;AAClC,uBAAuB,WAAW;AAClC,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,QAAQ;AACvC,uBAAuB,WAAW;AAClC,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACzFa;;AAEb,aAAa,mBAAO,CAAC,uBAAW;AAChC,iBAAiB,mBAAO,CAAC,oBAAQ;;AAEjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,eAAe,OAAO;AACtB;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,OAAO;AAC1B,uBAAuB,WAAW;AAClC;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B,uBAAuB,WAAW;AAClC;AACA;AACA,uBAAuB,OAAO;AAC9B,2BAA2B,WAAW;AACtC;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,uBAAuB,aAAa;AACpC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,uBAAuB,OAAO;AAC9B;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,QAAQ;AACrC,uBAAuB,UAAU;AACjC;AACA;AACA;AACA,uBAAuB,aAAa;AACpC;AACA;AACA,+BAA+B,UAAU;AACzC;AACA;;AAEA;;AAEA,+BAA+B,UAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvJA;AACA;AACA;AACA,aAAa,mBAAO,CAAC,uBAAW;AAChC,WAAW,mBAAO,CAAC,uBAAW;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,iCAAiC;;AAEjC,2BAA2B;AAC3B,yBAAyB;;AAEzB;AACA,wBAAwB,YAAY;AACpC;AACA;;AAEA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA,8BAA8B,YAAY;AAC1C,kCAAkC,gBAAgB;AAClD,0CAA0C;AAC1C,0CAA0C,qCAAqC;AAC/E,8BAA8B;AAC9B,8BAA8B;AAC9B;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,4BAA4B;AAChE,oCAAoC;AACpC,oCAAoC;AACpC,oCAAoC;AACpC,oCAAoC;AACpC,oCAAoC;AACpC,oCAAoC;AACpC,oCAAoC;AACpC,oCAAoC;AACpC,oCAAoC;AACpC;AACA;;AAEA;;;AAGA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;;AAEA,8BAA8B;AAC9B,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,oDAAoD;AACpD;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,0BAA0B,YAAY;AACtC;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA,0CAA0C;;AAE1C,oBAAoB,eAAe;AACnC;AACA;AACA,6DAA6D;;AAE7D,gEAAgE;AAChE;AACA,2DAA2D;;AAE3D;;AAEA,oCAAoC;AACpC;AACA;AACA;AACA,iJAAiJ;;AAEjJ;AACA,4BAA4B,aAAa;AACzC;AACA;;AAEA,0CAA0C;AAC1C,8DAA8D;;AAE9D,gEAAgE;AAChE;AACA,+DAA+D;AAC/D;AACA;;AAEA,oEAAoE;AACpE;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA,0BAA0B;;AAE1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,4BAA4B;AAC5B,8CAA8C;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,gBAAgB;AAChB,KAAK;;AAEL;AACA,mCAAmC,GAAG,EAAE,EAAE;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA,yDAAyD;;AAEzD;AACA;AACA;;AAEA,yBAAyB;AACzB,yBAAyB;;AAEzB;;AAEA,2BAA2B;AAC3B;AACA,mDAAmD;;AAEnD,uBAAuB,MAAM;AAC7B;AACA,iDAAiD;AACjD,qCAAqC;AACrC;;AAEA;AACA;AACA;AACA,mCAAmC;AACnC,2EAA2E;AAC3E;AACA;AACA;AACA,gCAAgC,KAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,KAAK;AACrC;AACA;;AAEA,iBAAiB;AACjB;;AAEA,yBAAyB;;AAEzB;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E;AAC3E;AACA;AACA,2EAA2E;AAC3E;AACA,yEAAyE;AACzE;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kDAAkD;AAClD;AACA;AACA;AACA,KAAK;;AAEL;AACA,kGAAkG,GAAG,EAAE,EAAE;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA,gCAAgC;AAChC,4BAA4B;;AAE5B;;;AAGA;AACA;;AAEA,gCAAgC;AAChC;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;;AAGA,gBAAgB;AAChB;AACA;;;;AAIA;;AAEA,oB;;;;;;;;;;;ACtgBA,2BAA2B,mBAAO,CAAC,0BAAc;;;AAGjD,+BAA+B,mBAAO,CAAC,gCAAoB;AAC3D,cAAc,mBAAO,CAAC,mBAAO;;;;;;;;;;;;;ACJhB;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,mEAAmE;;AAEnE;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,cAAc;AACd,cAAc;;AAEd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,cAAc;AACd,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA,4B;;;;;;;;;;;;AC7Pa;;AAEb,eAAe,mBAAO,CAAC,oBAAQ;AAC/B,WAAW,mBAAO,CAAC,qBAAS;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA","file":"tabs-employee-map-employee-map-module.js","sourcesContent":["'use strict';\n\nrequire('./symbol-species');\nvar abstractMatrix = require('./abstractMatrix');\nvar util = require('./util');\n\nclass Matrix extends abstractMatrix(Array) {\n    constructor(nRows, nColumns) {\n        var i;\n        if (arguments.length === 1 && typeof nRows === 'number') {\n            return new Array(nRows);\n        }\n        if (Matrix.isMatrix(nRows)) {\n            return nRows.clone();\n        } else if (Number.isInteger(nRows) && nRows > 0) { // Create an empty matrix\n            super(nRows);\n            if (Number.isInteger(nColumns) && nColumns > 0) {\n                for (i = 0; i < nRows; i++) {\n                    this[i] = new Array(nColumns);\n                }\n            } else {\n                throw new TypeError('nColumns must be a positive integer');\n            }\n        } else if (Array.isArray(nRows)) { // Copy the values from the 2D array\n            const matrix = nRows;\n            nRows = matrix.length;\n            nColumns = matrix[0].length;\n            if (typeof nColumns !== 'number' || nColumns === 0) {\n                throw new TypeError('Data must be a 2D array with at least one element');\n            }\n            super(nRows);\n            for (i = 0; i < nRows; i++) {\n                if (matrix[i].length !== nColumns) {\n                    throw new RangeError('Inconsistent array dimensions');\n                }\n                this[i] = [].concat(matrix[i]);\n            }\n        } else {\n            throw new TypeError('First argument must be a positive number or an array');\n        }\n        this.rows = nRows;\n        this.columns = nColumns;\n        return this;\n    }\n\n    set(rowIndex, columnIndex, value) {\n        this[rowIndex][columnIndex] = value;\n        return this;\n    }\n\n    get(rowIndex, columnIndex) {\n        return this[rowIndex][columnIndex];\n    }\n\n    /**\n     * Creates an exact and independent copy of the matrix\n     * @return {Matrix}\n     */\n    clone() {\n        var newMatrix = new this.constructor[Symbol.species](this.rows, this.columns);\n        for (var row = 0; row < this.rows; row++) {\n            for (var column = 0; column < this.columns; column++) {\n                newMatrix.set(row, column, this.get(row, column));\n            }\n        }\n        return newMatrix;\n    }\n\n    /**\n     * Removes a row from the given index\n     * @param {number} index - Row index\n     * @return {Matrix} this\n     */\n    removeRow(index) {\n        util.checkRowIndex(this, index);\n        if (this.rows === 1) {\n            throw new RangeError('A matrix cannot have less than one row');\n        }\n        this.splice(index, 1);\n        this.rows -= 1;\n        return this;\n    }\n\n    /**\n     * Adds a row at the given index\n     * @param {number} [index = this.rows] - Row index\n     * @param {Array|Matrix} array - Array or vector\n     * @return {Matrix} this\n     */\n    addRow(index, array) {\n        if (array === undefined) {\n            array = index;\n            index = this.rows;\n        }\n        util.checkRowIndex(this, index, true);\n        array = util.checkRowVector(this, array, true);\n        this.splice(index, 0, array);\n        this.rows += 1;\n        return this;\n    }\n\n    /**\n     * Removes a column from the given index\n     * @param {number} index - Column index\n     * @return {Matrix} this\n     */\n    removeColumn(index) {\n        util.checkColumnIndex(this, index);\n        if (this.columns === 1) {\n            throw new RangeError('A matrix cannot have less than one column');\n        }\n        for (var i = 0; i < this.rows; i++) {\n            this[i].splice(index, 1);\n        }\n        this.columns -= 1;\n        return this;\n    }\n\n    /**\n     * Adds a column at the given index\n     * @param {number} [index = this.columns] - Column index\n     * @param {Array|Matrix} array - Array or vector\n     * @return {Matrix} this\n     */\n    addColumn(index, array) {\n        if (typeof array === 'undefined') {\n            array = index;\n            index = this.columns;\n        }\n        util.checkColumnIndex(this, index, true);\n        array = util.checkColumnVector(this, array);\n        for (var i = 0; i < this.rows; i++) {\n            this[i].splice(index, 0, array[i]);\n        }\n        this.columns += 1;\n        return this;\n    }\n}\n\nexports.Matrix = Matrix;\nMatrix.abstractMatrix = abstractMatrix;\n","import { Component, ChangeDetectorRef, Input } from '@angular/core';\r\nimport { IBeacon, IBeaconPluginResult } from '@ionic-native/ibeacon/ngx';\r\nimport { Platform } from '@ionic/angular';\r\nimport {\r\n  WifiScanResultsOptions,\r\n  WifiWizard2,\r\n} from '@ionic-native/wifi-wizard-2/ngx';\r\nimport {\r\n  Magnetometer,\r\n  MagnetometerReading,\r\n} from '@ionic-native/magnetometer/ngx';\r\nimport {\r\n  DeviceOrientation,\r\n  DeviceOrientationCompassHeading,\r\n} from '@ionic-native/device-orientation/ngx';\r\n\r\nimport { interval } from 'rxjs';\r\n\r\nimport { fabric } from 'fabric';\r\nimport {\r\n  AngularFirestore,\r\n  AngularFirestoreDocument,\r\n} from '@angular/fire/firestore';\r\nimport { AngularFireStorage } from '@angular/fire/storage';\r\n\r\nimport { Point } from './models/point';\r\nimport { MarkerInfo } from './models/marker-info';\r\nimport { MapInfo } from './models/map-info';\r\nimport { ChoiceInfo } from './models/choice-info';\r\nimport { TrilaterationService } from 'src/app/employee/services/trilateration/trilateration.service';\r\nimport { WebsocketService } from 'src/app/employee/services/websocket/websocket.service';\r\nimport { WebSocketSubject } from 'rxjs/webSocket';\r\nimport { PathfindingService } from 'src/app/employee/services/pathfinding/pathfinding.service';\r\n\r\n@Component({\r\n  selector: 'app-employee-map',\r\n  templateUrl: './employee-map.page.html',\r\n  styleUrls: ['./employee-map.page.scss'],\r\n})\r\nexport class EmployeeMapPage {\r\n  data;\r\n  beaconListData: MarkerInfo[] = [];\r\n  mainBeaconData = [];\r\n  //////////////////////////////////////////////\r\n  //////////////////////////////////////////////\r\n  //////////////////////////////////////////////\r\n  //////////////////////////////////////////////\r\n  // uuidMap of the map to download\r\n  uuidMap: string = 'a246ddf4-3ded-49b9-bacf-fbf7b700e49e';\r\n  private canvas: fabric.Canvas;\r\n\r\n  // icons\r\n  private exitIcon!: HTMLImageElement;\r\n  private entryIcon!: HTMLImageElement;\r\n  private beaconIcon!: HTMLImageElement;\r\n\r\n  // choices, so many choices\r\n  private choicesInfo: Record<string, ChoiceInfo> = {\r\n    exit: {\r\n      iconEl: this.exitIcon,\r\n      iconSrc: 'assets/img/exit.svg',\r\n    },\r\n    entry: {\r\n      iconEl: this.entryIcon,\r\n      iconSrc: 'assets/img/entry.svg',\r\n    },\r\n    beacon: {\r\n      iconEl: this.beaconIcon,\r\n      iconSrc: 'assets/img/beacon.svg',\r\n    },\r\n  };\r\n  // update this when updating above\r\n  private choices = ['exit', 'entry', 'beacon'];\r\n\r\n  // current position\r\n  currentPos: Point = new Point(517, 115);\r\n  drawnPath: fabric.Rect[] = [];\r\n\r\n  //////////////////////////////////////////////\r\n  //////////////////////////////////////////////\r\n\r\n  // trilateration\r\n  distances: number[] = [100, 100, 100, 100, 100, 100];\r\n  drawnCurrentLocation: fabric.Image;\r\n  headingAngle: number = 45;\r\n\r\n  // ws\r\n  userUuid: string = 'sampleasechangethis';\r\n  subject: WebSocketSubject<any>;\r\n\r\n  // navigation icon\r\n  private navIcon: HTMLImageElement;\r\n  private navIconSrc = 'assets/img/arrow.svg';\r\n\r\n  //////////////////////////////////////////////\r\n  //////////////////////////////////////////////\r\n\r\n  uuid = '74278bda-b644-4520-8f0c-720eaf059935';\r\n  beaconData = [];\r\n  beaconUuid: String;\r\n  scanStatus: boolean = false;\r\n  private delegate: any = null;\r\n  public beaconRegion: any = null;\r\n  public iosDevice: boolean = false;\r\n  options: WifiScanResultsOptions;\r\n\r\n  constructor(\r\n    private firestore: AngularFirestore,\r\n    private storage: AngularFireStorage,\r\n    //////////////////////////////////////////////\r\n    private readonly ibeacon: IBeacon,\r\n    private readonly platform: Platform,\r\n    private changeRef: ChangeDetectorRef,\r\n    private wifiWizard2: WifiWizard2,\r\n    private magnetometer: Magnetometer,\r\n    private deviceOrientation: DeviceOrientation,\r\n\r\n    // trilateration\r\n    private trilateration: TrilaterationService,\r\n    // ws\r\n    private socket: WebsocketService,\r\n\r\n    // pathfinding\r\n    private pathfinding: PathfindingService\r\n  ) {\r\n    this.platform.ready().then(() => {\r\n      this.requestLocPermissoin();\r\n      this.enableDebugLogs();\r\n    });\r\n\r\n    this.startScanning();\r\n    // interval(1000).subscribe((x) => {\r\n    //   this.startWifiScan();\r\n    // });\r\n    //////////////////////////////////////////////\r\n    this.handleSubmitClick(this.uuidMap);\r\n    this.getDirection();\r\n  }\r\n\r\n  ngOnInit() {\r\n    //SETUP BEACON LOCATIONS\r\n\r\n    //SETUP BEACON LOCATIONS\r\n    this.canvas = new fabric.Canvas('mapFabricCanvas');\r\n    this.canvas.selection = false;\r\n\r\n    this.canvas.height = 0;\r\n    this.canvas.width = 0;\r\n    this.choices.forEach((choice: string) => {\r\n      let choiceInfo = this.choicesInfo[choice];\r\n      choiceInfo.iconEl = new Image();\r\n      choiceInfo.iconEl.src = choiceInfo.iconSrc;\r\n    });\r\n\r\n    this.canvas.on('mouse:down', (e: fabric.IEvent) => {\r\n      if (e.pointer === undefined) {\r\n        console.log('aaaaa undefined');\r\n      } else {\r\n        console.log(e.pointer.x, e.pointer.y);\r\n        this.currentPos = new Point(e.pointer.x, e.pointer.y);\r\n      }\r\n    });\r\n    //////////////////////////////////////////////\r\n    if (!this.platform.is('ios')) {\r\n      this.iosDevice = true;\r\n    }\r\n\r\n    // ws\r\n    this.subject = this.socket.connectSocket('update?id=' + this.userUuid);\r\n    // download nav icon\r\n    this.navIcon = new Image();\r\n    this.navIcon.src = this.navIconSrc;\r\n  }\r\n\r\n  async getDirection() {\r\n    this.deviceOrientation.getCurrentHeading().then(\r\n      (data: DeviceOrientationCompassHeading) => {\r\n        console.log(data);\r\n      },\r\n      (error: any) => console.log(error)\r\n    );\r\n    // localhost:8100/employee/employee-tabs\r\n    // Watch the device compass heading change\r\n    var subscription = this.deviceOrientation\r\n      .watchHeading()\r\n      .subscribe((data: DeviceOrientationCompassHeading) => {\r\n        this.headingAngle = data.magneticHeading;\r\n        if (this.drawnCurrentLocation) {\r\n          console.log(this.headingAngle);\r\n          this.drawnCurrentLocation.angle = this.headingAngle;\r\n          // this.drawnCurrentLocation.setAngle(this.headingAngle);\r\n          this.drawnCurrentLocation.setCoords();\r\n          this.canvas.requestRenderAll();\r\n        }\r\n        // this.headingAngle = data.magneticHeading;\r\n        // this.drawnCurrentLocation.angle = this.headingAngle;\r\n        // console.log(this.headingAngle);\r\n        // this.drawnCurrentLocation.setAngle(this.headingAngle);\r\n        // this.drawnCurrentLocation.setCoords();\r\n        // this.canvas.requestRenderAll();\r\n        console.log(data);\r\n      });\r\n  }\r\n\r\n  async startWifiScan() {\r\n    // const SSID = await this.wifiWizard2.getConnectedSSID();\r\n    // console.log(SSID);\r\n    // const BSSID = await this.wifiWizard2.getConnectedBSSID();\r\n    // console.log(BSSID);\r\n    const scan = await this.wifiWizard2.scan();\r\n    console.log(scan);\r\n    const x = await this.wifiWizard2.getScanResults(this.options);\r\n    console.log(x);\r\n  }\r\n\r\n  requestLocPermissoin(): void {\r\n    // Request permission to use location on iOS\r\n    if (this.platform.is('ios')) {\r\n      this.ibeacon.requestAlwaysAuthorization();\r\n      console.log(`: request ios permisson`);\r\n    }\r\n  }\r\n\r\n  enableDebugLogs(): void {\r\n    this.ibeacon.enableDebugLogs();\r\n    this.ibeacon.enableDebugNotifications();\r\n  }\r\n\r\n  public onScanClicked(): void {\r\n    if (!this.scanStatus) {\r\n      this.startScanning();\r\n      this.scanStatus = true;\r\n    } else {\r\n      this.scanStatus = false;\r\n      this.stopScannning();\r\n    }\r\n  }\r\n\r\n  public stopScannning(): void {\r\n    // stop ranging\r\n    this.ibeacon\r\n      .stopRangingBeaconsInRegion(this.beaconRegion)\r\n      .then(async () => {\r\n        console.log(`Stopped ranging beacon region:`, this.beaconRegion);\r\n      })\r\n      .catch((error: any) => {\r\n        console.log(\r\n          `Failed to stop ranging beacon region: `,\r\n          this.beaconRegion\r\n        );\r\n      });\r\n  }\r\n\r\n  startScanning() {\r\n    // create a new delegate and register it with the native layer\r\n    this.delegate = this.ibeacon.Delegate();\r\n\r\n    this.ibeacon.setDelegate(this.delegate);\r\n\r\n    this.beaconUuid = this.uuid;\r\n\r\n    console.log(\r\n      '--===--- Bluetooth state: ',\r\n      this.ibeacon.isBluetoothEnabled()\r\n    );\r\n\r\n    // Check bluetooth status Y.Q\r\n    this.ibeacon.isBluetoothEnabled().then(\r\n      (data) => console.log('-------=== Enabled', data),\r\n      (error: any) => console.error('-------=== Disabled', error)\r\n    );\r\n\r\n    // Subscribe to some of the delegate's event handlers\r\n    this.delegate.didRangeBeaconsInRegion().subscribe(\r\n      async (pluginResult: IBeaconPluginResult) => {\r\n        console.log('didRangeBeaconsInRegion: ', pluginResult);\r\n        console.log('found beacons size: ' + pluginResult.beacons.length);\r\n        if (pluginResult.beacons.length > 0) {\r\n          this.beaconData = pluginResult.beacons;\r\n          //WRITE CODE HERE\r\n          // for (let i = 0; i <= this.beaconData.length; i++) {\r\n          //   // this.data.push(this.beaconData[i].accuracy);\r\n          //   const obj = {\r\n          //     dist: this.beaconData[i].accuracy,\r\n          //     // proximity: this.beaconData[i].proximity,\r\n          //     // rssi: this.beaconData[i].rssi,\r\n          //     // tx: this.beaconData[i].tx,\r\n          //     beaconNo: this.beaconData[i].minor,\r\n          //   };\r\n\r\n          //   [1,1,2,2,3]\r\n          //   // this.statData.push(obj);\r\n          //   // console.log(this.beaconData[i].accuracy);\r\n          //   // console.log(this.beaconData[i].accuracy);\r\n          //   // console.log(this.statData);\r\n          // }\r\n\r\n          const beaconData2: any[] = JSON.parse(\r\n            JSON.stringify(this.beaconData)\r\n          );\r\n          beaconData2.sort((a, b) => {\r\n            return a.accuracy > b.accuracy\r\n              ? -1\r\n              : a.accuracy < b.accuracy\r\n              ? 1\r\n              : 0;\r\n          });\r\n          const beaconData3 = beaconData2.slice(0, 3);\r\n\r\n          const distArray = [0, 0, 0];\r\n          console.log(distArray);\r\n          for (let i = 0; i < beaconData3.length; i++) {\r\n            distArray[i] = beaconData3[i].accuracy * 100;\r\n\r\n            // this.trilateration.beacons[i] =\r\n            for (let beacon of this.mainBeaconData) {\r\n              if (beacon.beaconNo == beaconData3[i].minor) {\r\n                const x = beacon.x;\r\n                const y = beacon.y;\r\n                this.trilateration.beacons[i] = [x, y];\r\n                break;\r\n              }\r\n            }\r\n          }\r\n\r\n          console.log(distArray);\r\n          console.log('Calling Get Location');\r\n          this.getLocation(distArray);\r\n          //END HERE\r\n\r\n          this.changeRef.detectChanges(); // Check for data change to update view Y.Q\r\n        } else {\r\n          console.log('no beacons nearby');\r\n        }\r\n      },\r\n      (error: any) => console.error(`Failure during ranging: `, error)\r\n    );\r\n\r\n    this.delegate.didStartMonitoringForRegion().subscribe(\r\n      (pluginResult: IBeaconPluginResult) =>\r\n        console.log('didStartMonitoringForRegion: ', pluginResult),\r\n      (error: any) =>\r\n        console.error(`Failure during starting of monitoring: `, error)\r\n    );\r\n\r\n    console.log(`Creating BeaconRegion with UUID of: `, this.uuid);\r\n\r\n    // uuid is required, identifier and range are optional.\r\n    this.beaconRegion = this.ibeacon.BeaconRegion('EST3', this.uuid);\r\n\r\n    this.ibeacon.startMonitoringForRegion(this.beaconRegion).then(\r\n      () => console.log('Native layer recieved the request to monitoring'),\r\n      (error: any) =>\r\n        console.error('Native layer failed to begin monitoring: ', error)\r\n    );\r\n\r\n    this.ibeacon\r\n      .startRangingBeaconsInRegion(this.beaconRegion)\r\n      .then(() => {\r\n        console.log(`Started ranging beacon region: `, this.beaconRegion);\r\n      })\r\n      .catch((error: any) => {\r\n        console.error(\r\n          `Failed to start ranging beacon region: `,\r\n          this.beaconRegion\r\n        );\r\n      });\r\n  }\r\n\r\n  async handleSubmitClick(uuidMap: string) {\r\n    let orig_img = await this.pathfinding.initialize(uuidMap);\r\n    // this.canvas.setDimensions({\r\n    //   width: orig_img.width,\r\n    //   height: orig_img.height,\r\n    // });\r\n    this.canvas.setWidth(orig_img.width);\r\n    // this.canvas.height = orig_img.height;\r\n    this.canvas.setHeight(orig_img.height);\r\n    // this.canvas.width = orig_img.width;\r\n    this.canvas.setDimensions(\r\n      {\r\n        width: '100%',\r\n        height: '',\r\n      },\r\n      {\r\n        cssOnly: true,\r\n      }\r\n    );\r\n\r\n    const height = this.canvas.getHeight();\r\n    console.log('height is ', height);\r\n    this.canvas.hoverCursor = 'auto';\r\n\r\n    let orig_img_f = new fabric.Image(orig_img, {\r\n      left: 0,\r\n      top: 0,\r\n      lockMovementX: true,\r\n      lockMovementY: true,\r\n      lockScalingX: true,\r\n      selectable: false,\r\n    });\r\n    this.canvas.add(orig_img_f);\r\n\r\n    this.addMarkers();\r\n\r\n    this.getNearestExit();\r\n  }\r\n\r\n  private addMarkers() {\r\n    this.pathfinding.mapDoc\r\n      .get()\r\n      .toPromise()\r\n      .then(async (res) => {\r\n        const mapData = res.data();\r\n        console.log(mapData);\r\n\r\n        for (let marker of mapData.markers) {\r\n          if (marker.name == 'beacon') {\r\n            this.beaconListData.push(marker);\r\n          }\r\n          let iconImg = new fabric.Image(this.choicesInfo[marker.name].iconEl, {\r\n            left: marker.left,\r\n            top: marker.top,\r\n            selectable: false,\r\n            width: marker.width,\r\n            height: marker.height,\r\n          });\r\n          iconImg.data = { name: marker.name };\r\n          this.canvas.add(iconImg);\r\n        }\r\n        console.log('Hello Data');\r\n        console.log(this.beaconListData);\r\n        this.mainBeaconData = await this.setupBeaconData(this.beaconListData);\r\n        this.setupTrilateration();\r\n      });\r\n  }\r\n\r\n  private async setupBeaconData(beaconListData: MarkerInfo[]) {\r\n    const data = [];\r\n    for (let i = 0; i < beaconListData.length; i++) {\r\n      data.push({\r\n        beaconNo: i + 1,\r\n        x: beaconListData[i].left + beaconListData[i].width / 2,\r\n        y: beaconListData[i].top + beaconListData[i].height / 2,\r\n      });\r\n    }\r\n    console.log('New Data');\r\n    console.log(data);\r\n    return data;\r\n  }\r\n\r\n  private setupTrilateration() {\r\n    let beaconArr: Array<Array<number>> = [];\r\n    for (let i = 0; i < 3; i++) {\r\n      beaconArr.push([this.mainBeaconData[i].x, this.mainBeaconData[i].y]);\r\n    }\r\n    console.log('INIT BEACON');\r\n    console.log(beaconArr);\r\n    console.log('INIT BEACON');\r\n    this.trilateration.initializeBeacons(beaconArr);\r\n  }\r\n\r\n  private async getLocation(distArray) {\r\n    const pos = this.trilateration.getLocation(distArray);\r\n    console.log('Got trilatered position', pos);\r\n\r\n    // draw dot/image\r\n    this.currentPos.x = pos[0];\r\n    this.currentPos.y = pos[1];\r\n    if (this.drawnCurrentLocation) {\r\n      this.drawnCurrentLocation.left = pos[0];\r\n      this.drawnCurrentLocation.top = pos[1];\r\n      this.drawnCurrentLocation.setCoords();\r\n      this.canvas.requestRenderAll();\r\n    } else {\r\n      this.drawnCurrentLocation = new fabric.Image(this.navIcon, {\r\n        left: pos[0],\r\n        top: pos[1],\r\n        // height: 20,\r\n        // width: 20,\r\n        // fill: 'red',\r\n        selectable: false,\r\n        angle: this.headingAngle,\r\n      });\r\n      this.drawnCurrentLocation.scaleToHeight(20);\r\n      this.drawnCurrentLocation.scaleToWidth(20);\r\n      this.canvas.add(this.drawnCurrentLocation);\r\n    }\r\n\r\n    // send to ws server\r\n    this.socket.sendMessage(this.subject, {\r\n      x: pos[0],\r\n      y: pos[0],\r\n      name: this.userUuid,\r\n    });\r\n\r\n    this.getNearestExit();\r\n  }\r\n\r\n  private async getNearestExit() {\r\n    const curpos = { x: this.currentPos.x, y: this.currentPos.y };\r\n\r\n    // console.log(\r\n    //   'cur pos',\r\n    //   curposActual,\r\n    //   this.imgMatrix[curposActual.x][curposActual.y]\r\n    // );\r\n\r\n    // easystarjs\r\n    const minPath = (await this.pathfinding.getPath(\r\n      curpos,\r\n      this.pathfinding.exits\r\n    )) as Point[];\r\n\r\n    const path = minPath;\r\n    if (path == null) {\r\n      console.log('no path aaaaaaaaaa');\r\n    } else {\r\n      console.log('path found', path);\r\n      while (this.drawnPath.length != 0) {\r\n        let rect = this.drawnPath.pop();\r\n        this.canvas.remove(rect);\r\n      }\r\n\r\n      for (let point of path) {\r\n        // console.log(point, this.imgMatrix[point.y][point.x]);\r\n        var rect = new fabric.Rect({\r\n          left: point.x,\r\n          top: point.y,\r\n          fill: 'red',\r\n          width: 5,\r\n          height: 5,\r\n          angle: 45,\r\n          selectable: false,\r\n        });\r\n        this.canvas.add(rect);\r\n        this.drawnPath.push(rect);\r\n      }\r\n    }\r\n  }\r\n}\r\n","/**\n * Created by acastillo on 8/24/15.\n */\n/**\n * Non in-place function definitions, compatible with mathjs code *\n */\n\n'use strict';\n\nvar Matrix = require('ml-matrix');\n\nfunction matrix(A,B){\n    return new Matrix(A,B);\n}\n\nfunction ones(rows, cols){\n    return Matrix.ones(rows,cols);\n}\n\nfunction eye(rows, cols){\n    return Matrix.eye(rows, cols);\n}\n\nfunction zeros(rows, cols){\n    return Matrix.zeros(rows, cols);\n}\n\nfunction random(rows, cols){\n    return Matrix.rand(rows,cols);\n}\n\nfunction transpose(A){\n    if(typeof A == 'number')\n        return A;\n    var result = A.clone();\n    return result.transpose();\n}\n\nfunction add(A, B){\n    if(typeof A == 'number'&&typeof B === 'number')\n        return A+B;\n    if(typeof A == 'number')\n        return this.add(B,A);\n\n    var result = A.clone();\n    return result.add(B);\n\n}\n\nfunction subtract(A, B){\n    if(typeof A == 'number'&&typeof B === 'number')\n        return A-B;\n    if(typeof A == 'number')\n        return this.subtract(B,A);\n    var result = A.clone();\n    return result.sub(B);\n}\n\nfunction multiply(A, B){\n    if(typeof A == 'number'&&typeof B === 'number')\n        return A*B;\n    if(typeof A == 'number')\n        return this.multiply(B,A);\n\n    var result = A.clone();\n\n    if(typeof B === 'number')\n        result.mul(B);\n    else\n        result = result.mmul(B);\n\n    if(result.rows==1&&result.columns==1)\n        return result[0][0];\n    else\n        return result;\n\n}\n\nfunction dotMultiply(A, B){\n    var result = A.clone();\n    return result.mul(B);\n}\n\nfunction dotDivide(A, B){\n    var result = A.clone();\n    return result.div(B);\n}\n\nfunction diag(A){\n    var diag = null;\n    var rows = A.rows, cols = A.columns, j, r;\n    //It is an array\n    if(typeof cols === \"undefined\" && (typeof A)=='object'){\n        if(A[0]&&A[0].length){\n            rows = A.length;\n            cols = A[0].length;\n            r = Math.min(rows,cols);\n            diag = Matrix.zeros(cols, cols);\n            for (j = 0; j < cols; j++) {\n                diag[j][j]=A[j][j];\n            }\n        }\n        else{\n            cols = A.length;\n            diag = Matrix.zeros(cols, cols);\n            for (j = 0; j < cols; j++) {\n                diag[j][j]=A[j];\n            }\n        }\n\n    }\n    if(rows == 1){\n        diag = Matrix.zeros(cols, cols);\n        for (j = 0; j < cols; j++) {\n            diag[j][j]=A[0][j];\n        }\n    }\n    else{\n        if(rows>0 && cols > 0){\n            r = Math.min(rows,cols);\n            diag = new Array(r);\n            for (j = 0; j < r; j++) {\n                diag[j] = A[j][j];\n            }\n        }\n    }\n    return diag;\n}\n\nfunction min(A, B){\n    if(typeof A==='number' && typeof B ==='number')\n        return Math.min(A,B);\n    var ii = A.rows, jj = A.columns;\n    var result = new Matrix(ii,jj);\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            if (A[i][j] < B[i][j]) {\n                result[i][j] = A[i][j];\n            }\n            else{\n                result[i][j] = B[i][j];\n            }\n        }\n    }\n    return result;\n}\n\nfunction max(A, B){\n    if(typeof A==='number' && typeof B ==='number')\n        return Math.max(A,B);\n    var ii = A.rows, jj = A.columns;\n    var result = new Matrix(ii,jj);\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            if (A[i][j] > B[i][j]) {\n                result[i][j] = A[i][j];\n            }\n            else{\n                result[i][j] = B[i][j];\n            }\n        }\n    }\n    return result;\n}\n\nfunction sqrt(A){\n    if(typeof A==='number' )\n        return Math.sqrt(A);\n    var ii = A.rows, jj = A.columns;\n    var result = new Matrix(ii,jj);\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            result[i][j] = Math.sqrt(A[i][j]);\n\n        }\n    }\n    return result;\n}\n\nfunction abs(A){\n    if(typeof A==='number' )\n        return Math.abs(A);\n    var ii = A.rows, jj = A.columns;\n    var result = new Matrix(ii,jj);\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            result[i][j] = Math.abs(A[i][j]);\n\n        }\n    }\n    return result;\n}\n\nfunction exp(A){\n    if(typeof A==='number' )\n        return Math.sqrt(A);\n    var ii = A.rows, jj = A.columns;\n    var result = new Matrix(ii,jj);\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            result[i][j] = Math.exp(A[i][j]);\n        }\n    }\n    return result;\n}\n\nfunction dotPow(A, b){\n    if(typeof A==='number' )\n        return Math.pow(A,b);\n    //console.log(A);\n    var ii = A.rows, jj = A.columns;\n    var result = new Matrix(ii,jj);\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            result[i][j] = Math.pow(A[i][j],b);\n        }\n    }\n    return result;\n}\n\nfunction solve(A, B){\n    return A.solve(B);\n}\n\nfunction inv(A){\n    if(typeof A ===\"number\")\n        return 1/A;\n    return A.inverse();\n}\n\nmodule.exports = {\n    transpose:transpose,\n    add:add,\n    subtract:subtract,\n    multiply:multiply,\n    dotMultiply:dotMultiply,\n    dotDivide:dotDivide,\n    diag:diag,\n    min:min,\n    max:max,\n    solve:solve,\n    inv:inv,\n    sqrt:sqrt,\n    exp:exp,\n    dotPow:dotPow,\n    abs:abs,\n    matrix:matrix,\n    ones:ones,\n    zeros:zeros,\n    random:random,\n    eye:eye\n};\n","import { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\n\nimport { EmployeeMapPage } from './employee-map.page';\n\nconst routes: Routes = [\n  {\n    path: '',\n    component: EmployeeMapPage\n  }\n];\n\n@NgModule({\n  imports: [RouterModule.forChild(routes)],\n  exports: [RouterModule],\n})\nexport class EmployeeMapPageRoutingModule {}\n","'use strict';\n\nfunction compareNumbers(a, b) {\n    return a - b;\n}\n\n/**\n * Computes the sum of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.sum = function sum(values) {\n    var sum = 0;\n    for (var i = 0; i < values.length; i++) {\n        sum += values[i];\n    }\n    return sum;\n};\n\n/**\n * Computes the maximum of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.max = function max(values) {\n    var max = values[0];\n    var l = values.length;\n    for (var i = 1; i < l; i++) {\n        if (values[i] > max) max = values[i];\n    }\n    return max;\n};\n\n/**\n * Computes the minimum of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.min = function min(values) {\n    var min = values[0];\n    var l = values.length;\n    for (var i = 1; i < l; i++) {\n        if (values[i] < min) min = values[i];\n    }\n    return min;\n};\n\n/**\n * Computes the min and max of the given values\n * @param {Array} values\n * @returns {{min: number, max: number}}\n */\nexports.minMax = function minMax(values) {\n    var min = values[0];\n    var max = values[0];\n    var l = values.length;\n    for (var i = 1; i < l; i++) {\n        if (values[i] < min) min = values[i];\n        if (values[i] > max) max = values[i];\n    }\n    return {\n        min: min,\n        max: max\n    };\n};\n\n/**\n * Computes the arithmetic mean of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.arithmeticMean = function arithmeticMean(values) {\n    var sum = 0;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        sum += values[i];\n    }\n    return sum / l;\n};\n\n/**\n * {@link arithmeticMean}\n */\nexports.mean = exports.arithmeticMean;\n\n/**\n * Computes the geometric mean of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.geometricMean = function geometricMean(values) {\n    var mul = 1;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        mul *= values[i];\n    }\n    return Math.pow(mul, 1 / l);\n};\n\n/**\n * Computes the mean of the log of the given values\n * If the return value is exponentiated, it gives the same result as the\n * geometric mean.\n * @param {Array} values\n * @returns {number}\n */\nexports.logMean = function logMean(values) {\n    var lnsum = 0;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        lnsum += Math.log(values[i]);\n    }\n    return lnsum / l;\n};\n\n/**\n * Computes the weighted grand mean for a list of means and sample sizes\n * @param {Array} means - Mean values for each set of samples\n * @param {Array} samples - Number of original values for each set of samples\n * @returns {number}\n */\nexports.grandMean = function grandMean(means, samples) {\n    var sum = 0;\n    var n = 0;\n    var l = means.length;\n    for (var i = 0; i < l; i++) {\n        sum += samples[i] * means[i];\n        n += samples[i];\n    }\n    return sum / n;\n};\n\n/**\n * Computes the truncated mean of the given values using a given percentage\n * @param {Array} values\n * @param {number} percent - The percentage of values to keep (range: [0,1])\n * @param {boolean} [alreadySorted=false]\n * @returns {number}\n */\nexports.truncatedMean = function truncatedMean(values, percent, alreadySorted) {\n    if (alreadySorted === undefined) alreadySorted = false;\n    if (!alreadySorted) {\n        values = [].concat(values).sort(compareNumbers);\n    }\n    var l = values.length;\n    var k = Math.floor(l * percent);\n    var sum = 0;\n    for (var i = k; i < (l - k); i++) {\n        sum += values[i];\n    }\n    return sum / (l - 2 * k);\n};\n\n/**\n * Computes the harmonic mean of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.harmonicMean = function harmonicMean(values) {\n    var sum = 0;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        if (values[i] === 0) {\n            throw new RangeError('value at index ' + i + 'is zero');\n        }\n        sum += 1 / values[i];\n    }\n    return l / sum;\n};\n\n/**\n * Computes the contraharmonic mean of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.contraHarmonicMean = function contraHarmonicMean(values) {\n    var r1 = 0;\n    var r2 = 0;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        r1 += values[i] * values[i];\n        r2 += values[i];\n    }\n    if (r2 < 0) {\n        throw new RangeError('sum of values is negative');\n    }\n    return r1 / r2;\n};\n\n/**\n * Computes the median of the given values\n * @param {Array} values\n * @param {boolean} [alreadySorted=false]\n * @returns {number}\n */\nexports.median = function median(values, alreadySorted) {\n    if (alreadySorted === undefined) alreadySorted = false;\n    if (!alreadySorted) {\n        values = [].concat(values).sort(compareNumbers);\n    }\n    var l = values.length;\n    var half = Math.floor(l / 2);\n    if (l % 2 === 0) {\n        return (values[half - 1] + values[half]) * 0.5;\n    } else {\n        return values[half];\n    }\n};\n\n/**\n * Computes the variance of the given values\n * @param {Array} values\n * @param {boolean} [unbiased=true] - if true, divide by (n-1); if false, divide by n.\n * @returns {number}\n */\nexports.variance = function variance(values, unbiased) {\n    if (unbiased === undefined) unbiased = true;\n    var theMean = exports.mean(values);\n    var theVariance = 0;\n    var l = values.length;\n\n    for (var i = 0; i < l; i++) {\n        var x = values[i] - theMean;\n        theVariance += x * x;\n    }\n\n    if (unbiased) {\n        return theVariance / (l - 1);\n    } else {\n        return theVariance / l;\n    }\n};\n\n/**\n * Computes the standard deviation of the given values\n * @param {Array} values\n * @param {boolean} [unbiased=true] - if true, divide by (n-1); if false, divide by n.\n * @returns {number}\n */\nexports.standardDeviation = function standardDeviation(values, unbiased) {\n    return Math.sqrt(exports.variance(values, unbiased));\n};\n\nexports.standardError = function standardError(values) {\n    return exports.standardDeviation(values) / Math.sqrt(values.length);\n};\n\n/**\n * IEEE Transactions on biomedical engineering, vol. 52, no. 1, january 2005, p. 76-\n * Calculate the standard deviation via the Median of the absolute deviation\n *  The formula for the standard deviation only holds for Gaussian random variables.\n * @returns {{mean: number, stdev: number}}\n */\nexports.robustMeanAndStdev = function robustMeanAndStdev(y) {\n    var mean = 0, stdev = 0;\n    var length = y.length, i = 0;\n    for (i = 0; i < length; i++) {\n        mean += y[i];\n    }\n    mean /= length;\n    var averageDeviations = new Array(length);\n    for (i = 0; i < length; i++)\n        averageDeviations[i] = Math.abs(y[i] - mean);\n    averageDeviations.sort(compareNumbers);\n    if (length % 2 === 1) {\n        stdev = averageDeviations[(length - 1) / 2] / 0.6745;\n    } else {\n        stdev = 0.5 * (averageDeviations[length / 2] + averageDeviations[length / 2 - 1]) / 0.6745;\n    }\n\n    return {\n        mean: mean,\n        stdev: stdev\n    };\n};\n\nexports.quartiles = function quartiles(values, alreadySorted) {\n    if (typeof (alreadySorted) === 'undefined') alreadySorted = false;\n    if (!alreadySorted) {\n        values = [].concat(values).sort(compareNumbers);\n    }\n\n    var quart = values.length / 4;\n    var q1 = values[Math.ceil(quart) - 1];\n    var q2 = exports.median(values, true);\n    var q3 = values[Math.ceil(quart * 3) - 1];\n\n    return {q1: q1, q2: q2, q3: q3};\n};\n\nexports.pooledStandardDeviation = function pooledStandardDeviation(samples, unbiased) {\n    return Math.sqrt(exports.pooledVariance(samples, unbiased));\n};\n\nexports.pooledVariance = function pooledVariance(samples, unbiased) {\n    if (typeof (unbiased) === 'undefined') unbiased = true;\n    var sum = 0;\n    var length = 0, l = samples.length;\n    for (var i = 0; i < l; i++) {\n        var values = samples[i];\n        var vari = exports.variance(values);\n\n        sum += (values.length - 1) * vari;\n\n        if (unbiased)\n            length += values.length - 1;\n        else\n            length += values.length;\n    }\n    return sum / length;\n};\n\nexports.mode = function mode(values) {\n    var l = values.length,\n        itemCount = new Array(l),\n        i;\n    for (i = 0; i < l; i++) {\n        itemCount[i] = 0;\n    }\n    var itemArray = new Array(l);\n    var count = 0;\n\n    for (i = 0; i < l; i++) {\n        var index = itemArray.indexOf(values[i]);\n        if (index >= 0)\n            itemCount[index]++;\n        else {\n            itemArray[count] = values[i];\n            itemCount[count] = 1;\n            count++;\n        }\n    }\n\n    var maxValue = 0, maxIndex = 0;\n    for (i = 0; i < count; i++) {\n        if (itemCount[i] > maxValue) {\n            maxValue = itemCount[i];\n            maxIndex = i;\n        }\n    }\n\n    return itemArray[maxIndex];\n};\n\nexports.covariance = function covariance(vector1, vector2, unbiased) {\n    if (typeof (unbiased) === 'undefined') unbiased = true;\n    var mean1 = exports.mean(vector1);\n    var mean2 = exports.mean(vector2);\n\n    if (vector1.length !== vector2.length)\n        throw 'Vectors do not have the same dimensions';\n\n    var cov = 0, l = vector1.length;\n    for (var i = 0; i < l; i++) {\n        var x = vector1[i] - mean1;\n        var y = vector2[i] - mean2;\n        cov += x * y;\n    }\n\n    if (unbiased)\n        return cov / (l - 1);\n    else\n        return cov / l;\n};\n\nexports.skewness = function skewness(values, unbiased) {\n    if (typeof (unbiased) === 'undefined') unbiased = true;\n    var theMean = exports.mean(values);\n\n    var s2 = 0, s3 = 0, l = values.length;\n    for (var i = 0; i < l; i++) {\n        var dev = values[i] - theMean;\n        s2 += dev * dev;\n        s3 += dev * dev * dev;\n    }\n    var m2 = s2 / l;\n    var m3 = s3 / l;\n\n    var g = m3 / (Math.pow(m2, 3 / 2.0));\n    if (unbiased) {\n        var a = Math.sqrt(l * (l - 1));\n        var b = l - 2;\n        return (a / b) * g;\n    } else {\n        return g;\n    }\n};\n\nexports.kurtosis = function kurtosis(values, unbiased) {\n    if (typeof (unbiased) === 'undefined') unbiased = true;\n    var theMean = exports.mean(values);\n    var n = values.length, s2 = 0, s4 = 0;\n\n    for (var i = 0; i < n; i++) {\n        var dev = values[i] - theMean;\n        s2 += dev * dev;\n        s4 += dev * dev * dev * dev;\n    }\n    var m2 = s2 / n;\n    var m4 = s4 / n;\n\n    if (unbiased) {\n        var v = s2 / (n - 1);\n        var a = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));\n        var b = s4 / (v * v);\n        var c = ((n - 1) * (n - 1)) / ((n - 2) * (n - 3));\n\n        return a * b - 3 * c;\n    } else {\n        return m4 / (m2 * m2) - 3;\n    }\n};\n\nexports.entropy = function entropy(values, eps) {\n    if (typeof (eps) === 'undefined') eps = 0;\n    var sum = 0, l = values.length;\n    for (var i = 0; i < l; i++)\n        sum += values[i] * Math.log(values[i] + eps);\n    return -sum;\n};\n\nexports.weightedMean = function weightedMean(values, weights) {\n    var sum = 0, l = values.length;\n    for (var i = 0; i < l; i++)\n        sum += values[i] * weights[i];\n    return sum;\n};\n\nexports.weightedStandardDeviation = function weightedStandardDeviation(values, weights) {\n    return Math.sqrt(exports.weightedVariance(values, weights));\n};\n\nexports.weightedVariance = function weightedVariance(values, weights) {\n    var theMean = exports.weightedMean(values, weights);\n    var vari = 0, l = values.length;\n    var a = 0, b = 0;\n\n    for (var i = 0; i < l; i++) {\n        var z = values[i] - theMean;\n        var w = weights[i];\n\n        vari += w * (z * z);\n        b += w;\n        a += w * w;\n    }\n\n    return vari * (b / (b * b - a));\n};\n\nexports.center = function center(values, inPlace) {\n    if (typeof (inPlace) === 'undefined') inPlace = false;\n\n    var result = values;\n    if (!inPlace)\n        result = [].concat(values);\n\n    var theMean = exports.mean(result), l = result.length;\n    for (var i = 0; i < l; i++)\n        result[i] -= theMean;\n};\n\nexports.standardize = function standardize(values, standardDev, inPlace) {\n    if (typeof (standardDev) === 'undefined') standardDev = exports.standardDeviation(values);\n    if (typeof (inPlace) === 'undefined') inPlace = false;\n    var l = values.length;\n    var result = inPlace ? values : new Array(l);\n    for (var i = 0; i < l; i++)\n        result[i] = values[i] / standardDev;\n    return result;\n};\n\nexports.cumulativeSum = function cumulativeSum(array) {\n    var l = array.length;\n    var result = new Array(l);\n    result[0] = array[0];\n    for (var i = 1; i < l; i++)\n        result[i] = result[i - 1] + array[i];\n    return result;\n};\n","'use strict';\n\nexports.hypotenuse = function hypotenuse(a, b) {\n    var r;\n    if (Math.abs(a) > Math.abs(b)) {\n        r = b / a;\n        return Math.abs(a) * Math.sqrt(1 + r * r);\n    }\n    if (b !== 0) {\n        r = a / b;\n        return Math.abs(b) * Math.sqrt(1 + r * r);\n    }\n    return 0;\n};\n\n// For use in the decomposition algorithms. With big matrices, access time is\n// too long on elements from array subclass\n// todo check when it is fixed in v8\n// http://jsperf.com/access-and-write-array-subclass\nexports.getEmpty2DArray = function (rows, columns) {\n    var array = new Array(rows);\n    for (var i = 0; i < rows; i++) {\n        array[i] = new Array(columns);\n    }\n    return array;\n};\n\nexports.getFilled2DArray = function (rows, columns, value) {\n    var array = new Array(rows);\n    for (var i = 0; i < rows; i++) {\n        array[i] = new Array(columns);\n        for (var j = 0; j < columns; j++) {\n            array[i][j] = value;\n        }\n    }\n    return array;\n};\n","'use strict';\n\nvar Matrix = require('./matrix');\n\n/**\n * @private\n * Check that a row index is not out of bounds\n * @param {Matrix} matrix\n * @param {number} index\n * @param {boolean} [outer]\n */\nexports.checkRowIndex = function checkRowIndex(matrix, index, outer) {\n    var max = outer ? matrix.rows : matrix.rows - 1;\n    if (index < 0 || index > max) {\n        throw new RangeError('Row index out of range');\n    }\n};\n\n/**\n * @private\n * Check that a column index is not out of bounds\n * @param {Matrix} matrix\n * @param {number} index\n * @param {boolean} [outer]\n */\nexports.checkColumnIndex = function checkColumnIndex(matrix, index, outer) {\n    var max = outer ? matrix.columns : matrix.columns - 1;\n    if (index < 0 || index > max) {\n        throw new RangeError('Column index out of range');\n    }\n};\n\n/**\n * @private\n * Check that the provided vector is an array with the right length\n * @param {Matrix} matrix\n * @param {Array|Matrix} vector\n * @return {Array}\n * @throws {RangeError}\n */\nexports.checkRowVector = function checkRowVector(matrix, vector) {\n    if (vector.to1DArray) {\n        vector = vector.to1DArray();\n    }\n    if (vector.length !== matrix.columns) {\n        throw new RangeError('vector size must be the same as the number of columns');\n    }\n    return vector;\n};\n\n/**\n * @private\n * Check that the provided vector is an array with the right length\n * @param {Matrix} matrix\n * @param {Array|Matrix} vector\n * @return {Array}\n * @throws {RangeError}\n */\nexports.checkColumnVector = function checkColumnVector(matrix, vector) {\n    if (vector.to1DArray) {\n        vector = vector.to1DArray();\n    }\n    if (vector.length !== matrix.rows) {\n        throw new RangeError('vector size must be the same as the number of rows');\n    }\n    return vector;\n};\n\nexports.checkIndices = function checkIndices(matrix, rowIndices, columnIndices) {\n    var rowOut = rowIndices.some(r => {\n        return r < 0 || r >= matrix.rows;\n\n    });\n\n    var columnOut = columnIndices.some(c => {\n        return c < 0 || c >= matrix.columns;\n    });\n\n    if (rowOut || columnOut) {\n        throw new RangeError('Indices are out of range');\n    }\n\n    if (typeof rowIndices !== 'object' || typeof columnIndices !== 'object') {\n        throw new TypeError('Unexpected type for row/column indices');\n    }\n    if (!Array.isArray(rowIndices)) rowIndices = Array.from(rowIndices);\n    if (!Array.isArray(columnIndices)) rowIndices = Array.from(columnIndices);\n\n    return {\n        row: rowIndices,\n        column: columnIndices\n    };\n};\n\nexports.checkRange = function checkRange(matrix, startRow, endRow, startColumn, endColumn) {\n    if (arguments.length !== 5) throw new TypeError('Invalid argument type');\n    var notAllNumbers = Array.from(arguments).slice(1).some(function (arg) {\n        return typeof arg !== 'number';\n    });\n    if (notAllNumbers) throw new TypeError('Invalid argument type');\n    if (startRow > endRow || startColumn > endColumn || startRow < 0 || startRow >= matrix.rows || endRow < 0 || endRow >= matrix.rows || startColumn < 0 || startColumn >= matrix.columns || endColumn < 0 || endColumn >= matrix.columns) {\n        throw new RangeError('Submatrix indices are out of range');\n    }\n};\n\nexports.getRange = function getRange(from, to) {\n    var arr = new Array(to - from + 1);\n    for (var i = 0; i < arr.length; i++) {\n        arr[i] = from + i;\n    }\n    return arr;\n};\n\nexports.sumByRow = function sumByRow(matrix) {\n    var sum = Matrix.Matrix.zeros(matrix.rows, 1);\n    for (var i = 0; i < matrix.rows; ++i) {\n        for (var j = 0; j < matrix.columns; ++j) {\n            sum.set(i, 0, sum.get(i, 0) + matrix.get(i, j));\n        }\n    }\n    return sum;\n};\n\nexports.sumByColumn = function sumByColumn(matrix) {\n    var sum = Matrix.Matrix.zeros(1, matrix.columns);\n    for (var i = 0; i < matrix.rows; ++i) {\n        for (var j = 0; j < matrix.columns; ++j) {\n            sum.set(0, j, sum.get(0, j) + matrix.get(i, j));\n        }\n    }\n    return sum;\n};\n\nexports.sumAll = function sumAll(matrix) {\n    var v = 0;\n    for (var i = 0; i < matrix.rows; i++) {\n        for (var j = 0; j < matrix.columns; j++) {\n            v += matrix.get(i, j);\n        }\n    }\n    return v;\n};\n","'use strict';\n\nvar BaseView = require('./base');\n\nclass MatrixFlipRowView extends BaseView {\n    constructor(matrix) {\n        super(matrix, matrix.rows, matrix.columns);\n    }\n\n    set(rowIndex, columnIndex, value) {\n        this.matrix.set(this.rows - rowIndex - 1, columnIndex, value);\n        return this;\n    }\n\n    get(rowIndex, columnIndex) {\n        return this.matrix.get(this.rows - rowIndex - 1, columnIndex);\n    }\n}\n\nmodule.exports = MatrixFlipRowView;\n","'use strict';\n\nif (!Symbol.species) {\n    Symbol.species = Symbol.for('@@species');\n}\n","'use strict';\n\nvar Matrix = require('../matrix');\n\n// https://github.com/lutzroeder/Mapack/blob/master/Source/LuDecomposition.cs\nfunction LuDecomposition(matrix) {\n    if (!(this instanceof LuDecomposition)) {\n        return new LuDecomposition(matrix);\n    }\n\n    matrix = Matrix.Matrix.checkMatrix(matrix);\n\n    var lu = matrix.clone(),\n        rows = lu.rows,\n        columns = lu.columns,\n        pivotVector = new Array(rows),\n        pivotSign = 1,\n        i, j, k, p, s, t, v,\n        LUrowi, LUcolj, kmax;\n\n    for (i = 0; i < rows; i++) {\n        pivotVector[i] = i;\n    }\n\n    LUcolj = new Array(rows);\n\n    for (j = 0; j < columns; j++) {\n\n        for (i = 0; i < rows; i++) {\n            LUcolj[i] = lu[i][j];\n        }\n\n        for (i = 0; i < rows; i++) {\n            LUrowi = lu[i];\n            kmax = Math.min(i, j);\n            s = 0;\n            for (k = 0; k < kmax; k++) {\n                s += LUrowi[k] * LUcolj[k];\n            }\n            LUrowi[j] = LUcolj[i] -= s;\n        }\n\n        p = j;\n        for (i = j + 1; i < rows; i++) {\n            if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])) {\n                p = i;\n            }\n        }\n\n        if (p !== j) {\n            for (k = 0; k < columns; k++) {\n                t = lu[p][k];\n                lu[p][k] = lu[j][k];\n                lu[j][k] = t;\n            }\n\n            v = pivotVector[p];\n            pivotVector[p] = pivotVector[j];\n            pivotVector[j] = v;\n\n            pivotSign = -pivotSign;\n        }\n\n        if (j < rows && lu[j][j] !== 0) {\n            for (i = j + 1; i < rows; i++) {\n                lu[i][j] /= lu[j][j];\n            }\n        }\n    }\n\n    this.LU = lu;\n    this.pivotVector = pivotVector;\n    this.pivotSign = pivotSign;\n}\n\nLuDecomposition.prototype = {\n    isSingular: function () {\n        var data = this.LU,\n            col = data.columns;\n        for (var j = 0; j < col; j++) {\n            if (data[j][j] === 0) {\n                return true;\n            }\n        }\n        return false;\n    },\n    get determinant() {\n        var data = this.LU;\n        if (!data.isSquare()) {\n            throw new Error('Matrix must be square');\n        }\n        var determinant = this.pivotSign, col = data.columns;\n        for (var j = 0; j < col; j++) {\n            determinant *= data[j][j];\n        }\n        return determinant;\n    },\n    get lowerTriangularMatrix() {\n        var data = this.LU,\n            rows = data.rows,\n            columns = data.columns,\n            X = new Matrix.Matrix(rows, columns);\n        for (var i = 0; i < rows; i++) {\n            for (var j = 0; j < columns; j++) {\n                if (i > j) {\n                    X[i][j] = data[i][j];\n                } else if (i === j) {\n                    X[i][j] = 1;\n                } else {\n                    X[i][j] = 0;\n                }\n            }\n        }\n        return X;\n    },\n    get upperTriangularMatrix() {\n        var data = this.LU,\n            rows = data.rows,\n            columns = data.columns,\n            X = new Matrix.Matrix(rows, columns);\n        for (var i = 0; i < rows; i++) {\n            for (var j = 0; j < columns; j++) {\n                if (i <= j) {\n                    X[i][j] = data[i][j];\n                } else {\n                    X[i][j] = 0;\n                }\n            }\n        }\n        return X;\n    },\n    get pivotPermutationVector() {\n        return this.pivotVector.slice();\n    },\n    solve: function (value) {\n        value = Matrix.Matrix.checkMatrix(value);\n\n        var lu = this.LU,\n            rows = lu.rows;\n\n        if (rows !== value.rows) {\n            throw new Error('Invalid matrix dimensions');\n        }\n        if (this.isSingular()) {\n            throw new Error('LU matrix is singular');\n        }\n\n        var count = value.columns;\n        var X = value.subMatrixRow(this.pivotVector, 0, count - 1);\n        var columns = lu.columns;\n        var i, j, k;\n\n        for (k = 0; k < columns; k++) {\n            for (i = k + 1; i < columns; i++) {\n                for (j = 0; j < count; j++) {\n                    X[i][j] -= X[k][j] * lu[i][k];\n                }\n            }\n        }\n        for (k = columns - 1; k >= 0; k--) {\n            for (j = 0; j < count; j++) {\n                X[k][j] /= lu[k][k];\n            }\n            for (i = 0; i < k; i++) {\n                for (j = 0; j < count; j++) {\n                    X[i][j] -= X[k][j] * lu[i][k];\n                }\n            }\n        }\n        return X;\n    }\n};\n\nmodule.exports = LuDecomposition;\n","export default \"\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJlbXBsb3llZS1tYXAucGFnZS5zY3NzIn0= */\";","'use strict';\n\nvar Matrix = require('./matrix').Matrix;\n\nvar SingularValueDecomposition = require('./dc/svd');\nvar EigenvalueDecomposition = require('./dc/evd');\nvar LuDecomposition = require('./dc/lu');\nvar QrDecomposition = require('./dc/qr');\nvar CholeskyDecomposition = require('./dc/cholesky');\n\nfunction inverse(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    return solve(matrix, Matrix.eye(matrix.rows));\n}\n\n/**\n * Returns the inverse\n * @memberOf Matrix\n * @static\n * @param {Matrix} matrix\n * @return {Matrix} matrix\n * @alias inv\n */\nMatrix.inverse = Matrix.inv = inverse;\n\n/**\n * Returns the inverse\n * @memberOf Matrix\n * @static\n * @param {Matrix} matrix\n * @return {Matrix} matrix\n * @alias inv\n */\nMatrix.prototype.inverse = Matrix.prototype.inv = function () {\n    return inverse(this);\n};\n\nfunction solve(leftHandSide, rightHandSide) {\n    leftHandSide = Matrix.checkMatrix(leftHandSide);\n    rightHandSide = Matrix.checkMatrix(rightHandSide);\n    return leftHandSide.isSquare() ? new LuDecomposition(leftHandSide).solve(rightHandSide) : new QrDecomposition(leftHandSide).solve(rightHandSide);\n}\n\nMatrix.solve = solve;\nMatrix.prototype.solve = function (other) {\n    return solve(this, other);\n};\n\nmodule.exports = {\n    SingularValueDecomposition: SingularValueDecomposition,\n    SVD: SingularValueDecomposition,\n    EigenvalueDecomposition: EigenvalueDecomposition,\n    EVD: EigenvalueDecomposition,\n    LuDecomposition: LuDecomposition,\n    LU: LuDecomposition,\n    QrDecomposition: QrDecomposition,\n    QR: QrDecomposition,\n    CholeskyDecomposition: CholeskyDecomposition,\n    CHO: CholeskyDecomposition,\n    inverse: inverse,\n    solve: solve\n};\n","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule } from '@angular/forms';\n\nimport { IonicModule } from '@ionic/angular';\n\nimport { EmployeeMapPageRoutingModule } from './employee-map-routing.module';\n\nimport { EmployeeMapPage } from './employee-map.page';\n\n@NgModule({\n  imports: [\n    CommonModule,\n    FormsModule,\n    IonicModule,\n    EmployeeMapPageRoutingModule\n  ],\n  declarations: [EmployeeMapPage]\n})\nexport class EmployeeMapPageModule {}\n","'use strict';\n\nvar BaseView = require('./base');\n\nclass MatrixFlipColumnView extends BaseView {\n    constructor(matrix) {\n        super(matrix, matrix.rows, matrix.columns);\n    }\n\n    set(rowIndex, columnIndex, value) {\n        this.matrix.set(rowIndex, this.columns - columnIndex - 1, value);\n        return this;\n    }\n\n    get(rowIndex, columnIndex) {\n        return this.matrix.get(rowIndex, this.columns - columnIndex - 1);\n    }\n}\n\nmodule.exports = MatrixFlipColumnView;\n","'use strict';\n\nconst Matrix = require('../matrix').Matrix;\nconst util = require('./util');\nconst hypotenuse = util.hypotenuse;\nconst getFilled2DArray = util.getFilled2DArray;\n\nconst defaultOptions = {\n    assumeSymmetric: false\n};\n\n// https://github.com/lutzroeder/Mapack/blob/master/Source/EigenvalueDecomposition.cs\nfunction EigenvalueDecomposition(matrix, options) {\n    options = Object.assign({}, defaultOptions, options);\n    if (!(this instanceof EigenvalueDecomposition)) {\n        return new EigenvalueDecomposition(matrix, options);\n    }\n    matrix = Matrix.checkMatrix(matrix);\n    if (!matrix.isSquare()) {\n        throw new Error('Matrix is not a square matrix');\n    }\n\n    var n = matrix.columns,\n        V = getFilled2DArray(n, n, 0),\n        d = new Array(n),\n        e = new Array(n),\n        value = matrix,\n        i, j;\n\n    var isSymmetric = false;\n    if (options.assumeSymmetric) {\n        isSymmetric = true;\n    } else {\n        isSymmetric = matrix.isSymmetric();\n    }\n\n    if (isSymmetric) {\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < n; j++) {\n                V[i][j] = value.get(i, j);\n            }\n        }\n        tred2(n, e, d, V);\n        tql2(n, e, d, V);\n    } else {\n        var H = getFilled2DArray(n, n, 0),\n            ort = new Array(n);\n        for (j = 0; j < n; j++) {\n            for (i = 0; i < n; i++) {\n                H[i][j] = value.get(i, j);\n            }\n        }\n        orthes(n, H, ort, V);\n        hqr2(n, e, d, V, H);\n    }\n\n    this.n = n;\n    this.e = e;\n    this.d = d;\n    this.V = V;\n}\n\nEigenvalueDecomposition.prototype = {\n    get realEigenvalues() {\n        return this.d;\n    },\n    get imaginaryEigenvalues() {\n        return this.e;\n    },\n    get eigenvectorMatrix() {\n        if (!Matrix.isMatrix(this.V)) {\n            this.V = new Matrix(this.V);\n        }\n        return this.V;\n    },\n    get diagonalMatrix() {\n        var n = this.n,\n            e = this.e,\n            d = this.d,\n            X = new Matrix(n, n),\n            i, j;\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < n; j++) {\n                X[i][j] = 0;\n            }\n            X[i][i] = d[i];\n            if (e[i] > 0) {\n                X[i][i + 1] = e[i];\n            } else if (e[i] < 0) {\n                X[i][i - 1] = e[i];\n            }\n        }\n        return X;\n    }\n};\n\nfunction tred2(n, e, d, V) {\n\n    var f, g, h, i, j, k,\n        hh, scale;\n\n    for (j = 0; j < n; j++) {\n        d[j] = V[n - 1][j];\n    }\n\n    for (i = n - 1; i > 0; i--) {\n        scale = 0;\n        h = 0;\n        for (k = 0; k < i; k++) {\n            scale = scale + Math.abs(d[k]);\n        }\n\n        if (scale === 0) {\n            e[i] = d[i - 1];\n            for (j = 0; j < i; j++) {\n                d[j] = V[i - 1][j];\n                V[i][j] = 0;\n                V[j][i] = 0;\n            }\n        } else {\n            for (k = 0; k < i; k++) {\n                d[k] /= scale;\n                h += d[k] * d[k];\n            }\n\n            f = d[i - 1];\n            g = Math.sqrt(h);\n            if (f > 0) {\n                g = -g;\n            }\n\n            e[i] = scale * g;\n            h = h - f * g;\n            d[i - 1] = f - g;\n            for (j = 0; j < i; j++) {\n                e[j] = 0;\n            }\n\n            for (j = 0; j < i; j++) {\n                f = d[j];\n                V[j][i] = f;\n                g = e[j] + V[j][j] * f;\n                for (k = j + 1; k <= i - 1; k++) {\n                    g += V[k][j] * d[k];\n                    e[k] += V[k][j] * f;\n                }\n                e[j] = g;\n            }\n\n            f = 0;\n            for (j = 0; j < i; j++) {\n                e[j] /= h;\n                f += e[j] * d[j];\n            }\n\n            hh = f / (h + h);\n            for (j = 0; j < i; j++) {\n                e[j] -= hh * d[j];\n            }\n\n            for (j = 0; j < i; j++) {\n                f = d[j];\n                g = e[j];\n                for (k = j; k <= i - 1; k++) {\n                    V[k][j] -= (f * e[k] + g * d[k]);\n                }\n                d[j] = V[i - 1][j];\n                V[i][j] = 0;\n            }\n        }\n        d[i] = h;\n    }\n\n    for (i = 0; i < n - 1; i++) {\n        V[n - 1][i] = V[i][i];\n        V[i][i] = 1;\n        h = d[i + 1];\n        if (h !== 0) {\n            for (k = 0; k <= i; k++) {\n                d[k] = V[k][i + 1] / h;\n            }\n\n            for (j = 0; j <= i; j++) {\n                g = 0;\n                for (k = 0; k <= i; k++) {\n                    g += V[k][i + 1] * V[k][j];\n                }\n                for (k = 0; k <= i; k++) {\n                    V[k][j] -= g * d[k];\n                }\n            }\n        }\n\n        for (k = 0; k <= i; k++) {\n            V[k][i + 1] = 0;\n        }\n    }\n\n    for (j = 0; j < n; j++) {\n        d[j] = V[n - 1][j];\n        V[n - 1][j] = 0;\n    }\n\n    V[n - 1][n - 1] = 1;\n    e[0] = 0;\n}\n\nfunction tql2(n, e, d, V) {\n\n    var g, h, i, j, k, l, m, p, r,\n        dl1, c, c2, c3, el1, s, s2,\n        iter;\n\n    for (i = 1; i < n; i++) {\n        e[i - 1] = e[i];\n    }\n\n    e[n - 1] = 0;\n\n    var f = 0,\n        tst1 = 0,\n        eps = Math.pow(2, -52);\n\n    for (l = 0; l < n; l++) {\n        tst1 = Math.max(tst1, Math.abs(d[l]) + Math.abs(e[l]));\n        m = l;\n        while (m < n) {\n            if (Math.abs(e[m]) <= eps * tst1) {\n                break;\n            }\n            m++;\n        }\n\n        if (m > l) {\n            iter = 0;\n            do {\n                iter = iter + 1;\n\n                g = d[l];\n                p = (d[l + 1] - g) / (2 * e[l]);\n                r = hypotenuse(p, 1);\n                if (p < 0) {\n                    r = -r;\n                }\n\n                d[l] = e[l] / (p + r);\n                d[l + 1] = e[l] * (p + r);\n                dl1 = d[l + 1];\n                h = g - d[l];\n                for (i = l + 2; i < n; i++) {\n                    d[i] -= h;\n                }\n\n                f = f + h;\n\n                p = d[m];\n                c = 1;\n                c2 = c;\n                c3 = c;\n                el1 = e[l + 1];\n                s = 0;\n                s2 = 0;\n                for (i = m - 1; i >= l; i--) {\n                    c3 = c2;\n                    c2 = c;\n                    s2 = s;\n                    g = c * e[i];\n                    h = c * p;\n                    r = hypotenuse(p, e[i]);\n                    e[i + 1] = s * r;\n                    s = e[i] / r;\n                    c = p / r;\n                    p = c * d[i] - s * g;\n                    d[i + 1] = h + s * (c * g + s * d[i]);\n\n                    for (k = 0; k < n; k++) {\n                        h = V[k][i + 1];\n                        V[k][i + 1] = s * V[k][i] + c * h;\n                        V[k][i] = c * V[k][i] - s * h;\n                    }\n                }\n\n                p = -s * s2 * c3 * el1 * e[l] / dl1;\n                e[l] = s * p;\n                d[l] = c * p;\n\n            }\n            while (Math.abs(e[l]) > eps * tst1);\n        }\n        d[l] = d[l] + f;\n        e[l] = 0;\n    }\n\n    for (i = 0; i < n - 1; i++) {\n        k = i;\n        p = d[i];\n        for (j = i + 1; j < n; j++) {\n            if (d[j] < p) {\n                k = j;\n                p = d[j];\n            }\n        }\n\n        if (k !== i) {\n            d[k] = d[i];\n            d[i] = p;\n            for (j = 0; j < n; j++) {\n                p = V[j][i];\n                V[j][i] = V[j][k];\n                V[j][k] = p;\n            }\n        }\n    }\n}\n\nfunction orthes(n, H, ort, V) {\n\n    var low = 0,\n        high = n - 1,\n        f, g, h, i, j, m,\n        scale;\n\n    for (m = low + 1; m <= high - 1; m++) {\n        scale = 0;\n        for (i = m; i <= high; i++) {\n            scale = scale + Math.abs(H[i][m - 1]);\n        }\n\n        if (scale !== 0) {\n            h = 0;\n            for (i = high; i >= m; i--) {\n                ort[i] = H[i][m - 1] / scale;\n                h += ort[i] * ort[i];\n            }\n\n            g = Math.sqrt(h);\n            if (ort[m] > 0) {\n                g = -g;\n            }\n\n            h = h - ort[m] * g;\n            ort[m] = ort[m] - g;\n\n            for (j = m; j < n; j++) {\n                f = 0;\n                for (i = high; i >= m; i--) {\n                    f += ort[i] * H[i][j];\n                }\n\n                f = f / h;\n                for (i = m; i <= high; i++) {\n                    H[i][j] -= f * ort[i];\n                }\n            }\n\n            for (i = 0; i <= high; i++) {\n                f = 0;\n                for (j = high; j >= m; j--) {\n                    f += ort[j] * H[i][j];\n                }\n\n                f = f / h;\n                for (j = m; j <= high; j++) {\n                    H[i][j] -= f * ort[j];\n                }\n            }\n\n            ort[m] = scale * ort[m];\n            H[m][m - 1] = scale * g;\n        }\n    }\n\n    for (i = 0; i < n; i++) {\n        for (j = 0; j < n; j++) {\n            V[i][j] = (i === j ? 1 : 0);\n        }\n    }\n\n    for (m = high - 1; m >= low + 1; m--) {\n        if (H[m][m - 1] !== 0) {\n            for (i = m + 1; i <= high; i++) {\n                ort[i] = H[i][m - 1];\n            }\n\n            for (j = m; j <= high; j++) {\n                g = 0;\n                for (i = m; i <= high; i++) {\n                    g += ort[i] * V[i][j];\n                }\n\n                g = (g / ort[m]) / H[m][m - 1];\n                for (i = m; i <= high; i++) {\n                    V[i][j] += g * ort[i];\n                }\n            }\n        }\n    }\n}\n\nfunction hqr2(nn, e, d, V, H) {\n    var n = nn - 1,\n        low = 0,\n        high = nn - 1,\n        eps = Math.pow(2, -52),\n        exshift = 0,\n        norm = 0,\n        p = 0,\n        q = 0,\n        r = 0,\n        s = 0,\n        z = 0,\n        iter = 0,\n        i, j, k, l, m, t, w, x, y,\n        ra, sa, vr, vi,\n        notlast, cdivres;\n\n    for (i = 0; i < nn; i++) {\n        if (i < low || i > high) {\n            d[i] = H[i][i];\n            e[i] = 0;\n        }\n\n        for (j = Math.max(i - 1, 0); j < nn; j++) {\n            norm = norm + Math.abs(H[i][j]);\n        }\n    }\n\n    while (n >= low) {\n        l = n;\n        while (l > low) {\n            s = Math.abs(H[l - 1][l - 1]) + Math.abs(H[l][l]);\n            if (s === 0) {\n                s = norm;\n            }\n            if (Math.abs(H[l][l - 1]) < eps * s) {\n                break;\n            }\n            l--;\n        }\n\n        if (l === n) {\n            H[n][n] = H[n][n] + exshift;\n            d[n] = H[n][n];\n            e[n] = 0;\n            n--;\n            iter = 0;\n        } else if (l === n - 1) {\n            w = H[n][n - 1] * H[n - 1][n];\n            p = (H[n - 1][n - 1] - H[n][n]) / 2;\n            q = p * p + w;\n            z = Math.sqrt(Math.abs(q));\n            H[n][n] = H[n][n] + exshift;\n            H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;\n            x = H[n][n];\n\n            if (q >= 0) {\n                z = (p >= 0) ? (p + z) : (p - z);\n                d[n - 1] = x + z;\n                d[n] = d[n - 1];\n                if (z !== 0) {\n                    d[n] = x - w / z;\n                }\n                e[n - 1] = 0;\n                e[n] = 0;\n                x = H[n][n - 1];\n                s = Math.abs(x) + Math.abs(z);\n                p = x / s;\n                q = z / s;\n                r = Math.sqrt(p * p + q * q);\n                p = p / r;\n                q = q / r;\n\n                for (j = n - 1; j < nn; j++) {\n                    z = H[n - 1][j];\n                    H[n - 1][j] = q * z + p * H[n][j];\n                    H[n][j] = q * H[n][j] - p * z;\n                }\n\n                for (i = 0; i <= n; i++) {\n                    z = H[i][n - 1];\n                    H[i][n - 1] = q * z + p * H[i][n];\n                    H[i][n] = q * H[i][n] - p * z;\n                }\n\n                for (i = low; i <= high; i++) {\n                    z = V[i][n - 1];\n                    V[i][n - 1] = q * z + p * V[i][n];\n                    V[i][n] = q * V[i][n] - p * z;\n                }\n            } else {\n                d[n - 1] = x + p;\n                d[n] = x + p;\n                e[n - 1] = z;\n                e[n] = -z;\n            }\n\n            n = n - 2;\n            iter = 0;\n        } else {\n            x = H[n][n];\n            y = 0;\n            w = 0;\n            if (l < n) {\n                y = H[n - 1][n - 1];\n                w = H[n][n - 1] * H[n - 1][n];\n            }\n\n            if (iter === 10) {\n                exshift += x;\n                for (i = low; i <= n; i++) {\n                    H[i][i] -= x;\n                }\n                s = Math.abs(H[n][n - 1]) + Math.abs(H[n - 1][n - 2]);\n                x = y = 0.75 * s;\n                w = -0.4375 * s * s;\n            }\n\n            if (iter === 30) {\n                s = (y - x) / 2;\n                s = s * s + w;\n                if (s > 0) {\n                    s = Math.sqrt(s);\n                    if (y < x) {\n                        s = -s;\n                    }\n                    s = x - w / ((y - x) / 2 + s);\n                    for (i = low; i <= n; i++) {\n                        H[i][i] -= s;\n                    }\n                    exshift += s;\n                    x = y = w = 0.964;\n                }\n            }\n\n            iter = iter + 1;\n\n            m = n - 2;\n            while (m >= l) {\n                z = H[m][m];\n                r = x - z;\n                s = y - z;\n                p = (r * s - w) / H[m + 1][m] + H[m][m + 1];\n                q = H[m + 1][m + 1] - z - r - s;\n                r = H[m + 2][m + 1];\n                s = Math.abs(p) + Math.abs(q) + Math.abs(r);\n                p = p / s;\n                q = q / s;\n                r = r / s;\n                if (m === l) {\n                    break;\n                }\n                if (Math.abs(H[m][m - 1]) * (Math.abs(q) + Math.abs(r)) < eps * (Math.abs(p) * (Math.abs(H[m - 1][m - 1]) + Math.abs(z) + Math.abs(H[m + 1][m + 1])))) {\n                    break;\n                }\n                m--;\n            }\n\n            for (i = m + 2; i <= n; i++) {\n                H[i][i - 2] = 0;\n                if (i > m + 2) {\n                    H[i][i - 3] = 0;\n                }\n            }\n\n            for (k = m; k <= n - 1; k++) {\n                notlast = (k !== n - 1);\n                if (k !== m) {\n                    p = H[k][k - 1];\n                    q = H[k + 1][k - 1];\n                    r = (notlast ? H[k + 2][k - 1] : 0);\n                    x = Math.abs(p) + Math.abs(q) + Math.abs(r);\n                    if (x !== 0) {\n                        p = p / x;\n                        q = q / x;\n                        r = r / x;\n                    }\n                }\n\n                if (x === 0) {\n                    break;\n                }\n\n                s = Math.sqrt(p * p + q * q + r * r);\n                if (p < 0) {\n                    s = -s;\n                }\n\n                if (s !== 0) {\n                    if (k !== m) {\n                        H[k][k - 1] = -s * x;\n                    } else if (l !== m) {\n                        H[k][k - 1] = -H[k][k - 1];\n                    }\n\n                    p = p + s;\n                    x = p / s;\n                    y = q / s;\n                    z = r / s;\n                    q = q / p;\n                    r = r / p;\n\n                    for (j = k; j < nn; j++) {\n                        p = H[k][j] + q * H[k + 1][j];\n                        if (notlast) {\n                            p = p + r * H[k + 2][j];\n                            H[k + 2][j] = H[k + 2][j] - p * z;\n                        }\n\n                        H[k][j] = H[k][j] - p * x;\n                        H[k + 1][j] = H[k + 1][j] - p * y;\n                    }\n\n                    for (i = 0; i <= Math.min(n, k + 3); i++) {\n                        p = x * H[i][k] + y * H[i][k + 1];\n                        if (notlast) {\n                            p = p + z * H[i][k + 2];\n                            H[i][k + 2] = H[i][k + 2] - p * r;\n                        }\n\n                        H[i][k] = H[i][k] - p;\n                        H[i][k + 1] = H[i][k + 1] - p * q;\n                    }\n\n                    for (i = low; i <= high; i++) {\n                        p = x * V[i][k] + y * V[i][k + 1];\n                        if (notlast) {\n                            p = p + z * V[i][k + 2];\n                            V[i][k + 2] = V[i][k + 2] - p * r;\n                        }\n\n                        V[i][k] = V[i][k] - p;\n                        V[i][k + 1] = V[i][k + 1] - p * q;\n                    }\n                }\n            }\n        }\n    }\n\n    if (norm === 0) {\n        return;\n    }\n\n    for (n = nn - 1; n >= 0; n--) {\n        p = d[n];\n        q = e[n];\n\n        if (q === 0) {\n            l = n;\n            H[n][n] = 1;\n            for (i = n - 1; i >= 0; i--) {\n                w = H[i][i] - p;\n                r = 0;\n                for (j = l; j <= n; j++) {\n                    r = r + H[i][j] * H[j][n];\n                }\n\n                if (e[i] < 0) {\n                    z = w;\n                    s = r;\n                } else {\n                    l = i;\n                    if (e[i] === 0) {\n                        H[i][n] = (w !== 0) ? (-r / w) : (-r / (eps * norm));\n                    } else {\n                        x = H[i][i + 1];\n                        y = H[i + 1][i];\n                        q = (d[i] - p) * (d[i] - p) + e[i] * e[i];\n                        t = (x * s - z * r) / q;\n                        H[i][n] = t;\n                        H[i + 1][n] = (Math.abs(x) > Math.abs(z)) ? ((-r - w * t) / x) : ((-s - y * t) / z);\n                    }\n\n                    t = Math.abs(H[i][n]);\n                    if ((eps * t) * t > 1) {\n                        for (j = i; j <= n; j++) {\n                            H[j][n] = H[j][n] / t;\n                        }\n                    }\n                }\n            }\n        } else if (q < 0) {\n            l = n - 1;\n\n            if (Math.abs(H[n][n - 1]) > Math.abs(H[n - 1][n])) {\n                H[n - 1][n - 1] = q / H[n][n - 1];\n                H[n - 1][n] = -(H[n][n] - p) / H[n][n - 1];\n            } else {\n                cdivres = cdiv(0, -H[n - 1][n], H[n - 1][n - 1] - p, q);\n                H[n - 1][n - 1] = cdivres[0];\n                H[n - 1][n] = cdivres[1];\n            }\n\n            H[n][n - 1] = 0;\n            H[n][n] = 1;\n            for (i = n - 2; i >= 0; i--) {\n                ra = 0;\n                sa = 0;\n                for (j = l; j <= n; j++) {\n                    ra = ra + H[i][j] * H[j][n - 1];\n                    sa = sa + H[i][j] * H[j][n];\n                }\n\n                w = H[i][i] - p;\n\n                if (e[i] < 0) {\n                    z = w;\n                    r = ra;\n                    s = sa;\n                } else {\n                    l = i;\n                    if (e[i] === 0) {\n                        cdivres = cdiv(-ra, -sa, w, q);\n                        H[i][n - 1] = cdivres[0];\n                        H[i][n] = cdivres[1];\n                    } else {\n                        x = H[i][i + 1];\n                        y = H[i + 1][i];\n                        vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;\n                        vi = (d[i] - p) * 2 * q;\n                        if (vr === 0 && vi === 0) {\n                            vr = eps * norm * (Math.abs(w) + Math.abs(q) + Math.abs(x) + Math.abs(y) + Math.abs(z));\n                        }\n                        cdivres = cdiv(x * r - z * ra + q * sa, x * s - z * sa - q * ra, vr, vi);\n                        H[i][n - 1] = cdivres[0];\n                        H[i][n] = cdivres[1];\n                        if (Math.abs(x) > (Math.abs(z) + Math.abs(q))) {\n                            H[i + 1][n - 1] = (-ra - w * H[i][n - 1] + q * H[i][n]) / x;\n                            H[i + 1][n] = (-sa - w * H[i][n] - q * H[i][n - 1]) / x;\n                        } else {\n                            cdivres = cdiv(-r - y * H[i][n - 1], -s - y * H[i][n], z, q);\n                            H[i + 1][n - 1] = cdivres[0];\n                            H[i + 1][n] = cdivres[1];\n                        }\n                    }\n\n                    t = Math.max(Math.abs(H[i][n - 1]), Math.abs(H[i][n]));\n                    if ((eps * t) * t > 1) {\n                        for (j = i; j <= n; j++) {\n                            H[j][n - 1] = H[j][n - 1] / t;\n                            H[j][n] = H[j][n] / t;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < nn; i++) {\n        if (i < low || i > high) {\n            for (j = i; j < nn; j++) {\n                V[i][j] = H[i][j];\n            }\n        }\n    }\n\n    for (j = nn - 1; j >= low; j--) {\n        for (i = low; i <= high; i++) {\n            z = 0;\n            for (k = low; k <= Math.min(j, high); k++) {\n                z = z + V[i][k] * H[k][j];\n            }\n            V[i][j] = z;\n        }\n    }\n}\n\nfunction cdiv(xr, xi, yr, yi) {\n    var r, d;\n    if (Math.abs(yr) > Math.abs(yi)) {\n        r = yi / yr;\n        d = yr + r * yi;\n        return [(xr + r * xi) / d, (xi - r * xr) / d];\n    } else {\n        r = yr / yi;\n        d = yi + r * yr;\n        return [(r * xr + xi) / d, (r * xi - xr) / d];\n    }\n}\n\nmodule.exports = EigenvalueDecomposition;\n","'use strict';\n\nexports.SNV = SNV;\nvar Stat = require('ml-stat').array;\n\n/**\n * Function that applies the standard normal variate (SNV) to an array of values.\n *\n * @param data - Array of values.\n * @returns {Array} - applied the SNV.\n */\nfunction SNV(data) {\n    var mean = Stat.mean(data);\n    var std = Stat.standardDeviation(data);\n    var result = data.slice();\n    for (var i = 0; i < data.length; i++) {\n        result[i] = (result[i] - mean) / std;\n    }\n    return result;\n}\n","import { Injectable } from '@angular/core';\r\nimport * as trilat from 'trilat';\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class TrilaterationService {\r\n  beacons: Array<Array<number>>;\r\n\r\n  constructor() { }\r\n\r\n  initializeBeacons(coords: Array<Array<number>>): Array<Array<number>> {\r\n    let newInput = [];\r\n\r\n    coords.forEach((coord) => {\r\n      newInput.push([coord[0], coord[1], 0]);\r\n    });\r\n\r\n    this.beacons = newInput;\r\n    return this.beacons;\r\n  }\r\n\r\n  getLocation(\r\n    distances: Array<number>\r\n  ): Array<number> {\r\n    if (this.beacons.length != distances.length) {\r\n      throw Error('Distances given do not match array length');\r\n    }\r\n\r\n    for (let i: number = 0; i < this.beacons.length; ++i) {\r\n      this.beacons[i][2] = distances[i];\r\n    }\r\n\r\n    var pos1 = trilat(this.beacons);\r\n\r\n    return pos1;\r\n  }\r\n}\r\n","'use strict';\n\nvar Matrix = require('../matrix');\nvar util = require('./util');\nvar hypotenuse = util.hypotenuse;\nvar getFilled2DArray = util.getFilled2DArray;\n\n// https://github.com/lutzroeder/Mapack/blob/master/Source/SingularValueDecomposition.cs\nfunction SingularValueDecomposition(value, options) {\n    if (!(this instanceof SingularValueDecomposition)) {\n        return new SingularValueDecomposition(value, options);\n    }\n    value = Matrix.Matrix.checkMatrix(value);\n\n    options = options || {};\n\n    var m = value.rows,\n        n = value.columns,\n        nu = Math.min(m, n);\n\n    var wantu = true, wantv = true;\n    if (options.computeLeftSingularVectors === false) wantu = false;\n    if (options.computeRightSingularVectors === false) wantv = false;\n    var autoTranspose = options.autoTranspose === true;\n\n    var swapped = false;\n    var a;\n    if (m < n) {\n        if (!autoTranspose) {\n            a = value.clone();\n            // eslint-disable-next-line no-console\n            console.warn('Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose');\n        } else {\n            a = value.transpose();\n            m = a.rows;\n            n = a.columns;\n            swapped = true;\n            var aux = wantu;\n            wantu = wantv;\n            wantv = aux;\n        }\n    } else {\n        a = value.clone();\n    }\n\n    var s = new Array(Math.min(m + 1, n)),\n        U = getFilled2DArray(m, nu, 0),\n        V = getFilled2DArray(n, n, 0),\n        e = new Array(n),\n        work = new Array(m);\n\n    var nct = Math.min(m - 1, n);\n    var nrt = Math.max(0, Math.min(n - 2, m));\n\n    var i, j, k, p, t, ks, f, cs, sn, max, kase,\n        scale, sp, spm1, epm1, sk, ek, b, c, shift, g;\n\n    for (k = 0, max = Math.max(nct, nrt); k < max; k++) {\n        if (k < nct) {\n            s[k] = 0;\n            for (i = k; i < m; i++) {\n                s[k] = hypotenuse(s[k], a[i][k]);\n            }\n            if (s[k] !== 0) {\n                if (a[k][k] < 0) {\n                    s[k] = -s[k];\n                }\n                for (i = k; i < m; i++) {\n                    a[i][k] /= s[k];\n                }\n                a[k][k] += 1;\n            }\n            s[k] = -s[k];\n        }\n\n        for (j = k + 1; j < n; j++) {\n            if ((k < nct) && (s[k] !== 0)) {\n                t = 0;\n                for (i = k; i < m; i++) {\n                    t += a[i][k] * a[i][j];\n                }\n                t = -t / a[k][k];\n                for (i = k; i < m; i++) {\n                    a[i][j] += t * a[i][k];\n                }\n            }\n            e[j] = a[k][j];\n        }\n\n        if (wantu && (k < nct)) {\n            for (i = k; i < m; i++) {\n                U[i][k] = a[i][k];\n            }\n        }\n\n        if (k < nrt) {\n            e[k] = 0;\n            for (i = k + 1; i < n; i++) {\n                e[k] = hypotenuse(e[k], e[i]);\n            }\n            if (e[k] !== 0) {\n                if (e[k + 1] < 0) {\n                    e[k] = 0 - e[k];\n                }\n                for (i = k + 1; i < n; i++) {\n                    e[i] /= e[k];\n                }\n                e[k + 1] += 1;\n            }\n            e[k] = -e[k];\n            if ((k + 1 < m) && (e[k] !== 0)) {\n                for (i = k + 1; i < m; i++) {\n                    work[i] = 0;\n                }\n                for (j = k + 1; j < n; j++) {\n                    for (i = k + 1; i < m; i++) {\n                        work[i] += e[j] * a[i][j];\n                    }\n                }\n                for (j = k + 1; j < n; j++) {\n                    t = -e[j] / e[k + 1];\n                    for (i = k + 1; i < m; i++) {\n                        a[i][j] += t * work[i];\n                    }\n                }\n            }\n            if (wantv) {\n                for (i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n    }\n\n    p = Math.min(n, m + 1);\n    if (nct < n) {\n        s[nct] = a[nct][nct];\n    }\n    if (m < p) {\n        s[p - 1] = 0;\n    }\n    if (nrt + 1 < p) {\n        e[nrt] = a[nrt][p - 1];\n    }\n    e[p - 1] = 0;\n\n    if (wantu) {\n        for (j = nct; j < nu; j++) {\n            for (i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (k = nct - 1; k >= 0; k--) {\n            if (s[k] !== 0) {\n                for (j = k + 1; j < nu; j++) {\n                    t = 0;\n                    for (i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n    }\n\n    if (wantv) {\n        for (k = n - 1; k >= 0; k--) {\n            if ((k < nrt) && (e[k] !== 0)) {\n                for (j = k + 1; j < n; j++) {\n                    t = 0;\n                    for (i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n    }\n\n    var pp = p - 1,\n        iter = 0,\n        eps = Math.pow(2, -52);\n    while (p > 0) {\n        for (k = p - 2; k >= -1; k--) {\n            if (k === -1) {\n                break;\n            }\n            if (Math.abs(e[k]) <= eps * (Math.abs(s[k]) + Math.abs(s[k + 1]))) {\n                e[k] = 0;\n                break;\n            }\n        }\n        if (k === p - 2) {\n            kase = 4;\n        } else {\n            for (ks = p - 1; ks >= k; ks--) {\n                if (ks === k) {\n                    break;\n                }\n                t = (ks !== p ? Math.abs(e[ks]) : 0) + (ks !== k + 1 ? Math.abs(e[ks - 1]) : 0);\n                if (Math.abs(s[ks]) <= eps * t) {\n                    s[ks] = 0;\n                    break;\n                }\n            }\n            if (ks === k) {\n                kase = 3;\n            } else if (ks === p - 1) {\n                kase = 1;\n            } else {\n                kase = 2;\n                k = ks;\n            }\n        }\n\n        k++;\n\n        switch (kase) {\n            case 1: {\n                f = e[p - 2];\n                e[p - 2] = 0;\n                for (j = p - 2; j >= k; j--) {\n                    t = hypotenuse(s[j], f);\n                    cs = s[j] / t;\n                    sn = f / t;\n                    s[j] = t;\n                    if (j !== k) {\n                        f = -sn * e[j - 1];\n                        e[j - 1] = cs * e[j - 1];\n                    }\n                    if (wantv) {\n                        for (i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n            }\n            case 2 : {\n                f = e[k - 1];\n                e[k - 1] = 0;\n                for (j = k; j < p; j++) {\n                    t = hypotenuse(s[j], f);\n                    cs = s[j] / t;\n                    sn = f / t;\n                    s[j] = t;\n                    f = -sn * e[j];\n                    e[j] = cs * e[j];\n                    if (wantu) {\n                        for (i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n            }\n            case 3 : {\n                scale = Math.max(Math.max(Math.max(Math.max(Math.abs(s[p - 1]), Math.abs(s[p - 2])), Math.abs(e[p - 2])), Math.abs(s[k])), Math.abs(e[k]));\n                sp = s[p - 1] / scale;\n                spm1 = s[p - 2] / scale;\n                epm1 = e[p - 2] / scale;\n                sk = s[k] / scale;\n                ek = e[k] / scale;\n                b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;\n                c = (sp * epm1) * (sp * epm1);\n                shift = 0;\n                if ((b !== 0) || (c !== 0)) {\n                    shift = Math.sqrt(b * b + c);\n                    if (b < 0) {\n                        shift = -shift;\n                    }\n                    shift = c / (b + shift);\n                }\n                f = (sk + sp) * (sk - sp) + shift;\n                g = sk * ek;\n                for (j = k; j < p - 1; j++) {\n                    t = hypotenuse(f, g);\n                    cs = f / t;\n                    sn = g / t;\n                    if (j !== k) {\n                        e[j - 1] = t;\n                    }\n                    f = cs * s[j] + sn * e[j];\n                    e[j] = cs * e[j] - sn * s[j];\n                    g = sn * s[j + 1];\n                    s[j + 1] = cs * s[j + 1];\n                    if (wantv) {\n                        for (i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                    }\n                    t = hypotenuse(f, g);\n                    cs = f / t;\n                    sn = g / t;\n                    s[j] = t;\n                    f = cs * e[j] + sn * s[j + 1];\n                    s[j + 1] = -sn * e[j] + cs * s[j + 1];\n                    g = sn * e[j + 1];\n                    e[j + 1] = cs * e[j + 1];\n                    if (wantu && (j < m - 1)) {\n                        for (i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][j + 1];\n                            U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                e[p - 2] = f;\n                iter = iter + 1;\n                break;\n            }\n            case 4: {\n                if (s[k] <= 0) {\n                    s[k] = (s[k] < 0 ? -s[k] : 0);\n                    if (wantv) {\n                        for (i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                }\n                while (k < pp) {\n                    if (s[k] >= s[k + 1]) {\n                        break;\n                    }\n                    t = s[k];\n                    s[k] = s[k + 1];\n                    s[k + 1] = t;\n                    if (wantv && (k < n - 1)) {\n                        for (i = 0; i < n; i++) {\n                            t = V[i][k + 1];\n                            V[i][k + 1] = V[i][k];\n                            V[i][k] = t;\n                        }\n                    }\n                    if (wantu && (k < m - 1)) {\n                        for (i = 0; i < m; i++) {\n                            t = U[i][k + 1];\n                            U[i][k + 1] = U[i][k];\n                            U[i][k] = t;\n                        }\n                    }\n                    k++;\n                }\n                iter = 0;\n                p--;\n                break;\n            }\n            // no default\n        }\n    }\n\n    if (swapped) {\n        var tmp = V;\n        V = U;\n        U = tmp;\n    }\n\n    this.m = m;\n    this.n = n;\n    this.s = s;\n    this.U = U;\n    this.V = V;\n}\n\nSingularValueDecomposition.prototype = {\n    get condition() {\n        return this.s[0] / this.s[Math.min(this.m, this.n) - 1];\n    },\n    get norm2() {\n        return this.s[0];\n    },\n    get rank() {\n        var eps = Math.pow(2, -52),\n            tol = Math.max(this.m, this.n) * this.s[0] * eps,\n            r = 0,\n            s = this.s;\n        for (var i = 0, ii = s.length; i < ii; i++) {\n            if (s[i] > tol) {\n                r++;\n            }\n        }\n        return r;\n    },\n    get diagonal() {\n        return this.s;\n    },\n    // https://github.com/accord-net/framework/blob/development/Sources/Accord.Math/Decompositions/SingularValueDecomposition.cs\n    get threshold() {\n        return (Math.pow(2, -52) / 2) * Math.max(this.m, this.n) * this.s[0];\n    },\n    get leftSingularVectors() {\n        if (!Matrix.Matrix.isMatrix(this.U)) {\n            this.U = new Matrix.Matrix(this.U);\n        }\n        return this.U;\n    },\n    get rightSingularVectors() {\n        if (!Matrix.Matrix.isMatrix(this.V)) {\n            this.V = new Matrix.Matrix(this.V);\n        }\n        return this.V;\n    },\n    get diagonalMatrix() {\n        return Matrix.Matrix.diag(this.s);\n    },\n    solve: function (value) {\n\n        var Y = value,\n            e = this.threshold,\n            scols = this.s.length,\n            Ls = Matrix.Matrix.zeros(scols, scols),\n            i;\n\n        for (i = 0; i < scols; i++) {\n            if (Math.abs(this.s[i]) <= e) {\n                Ls[i][i] = 0;\n            } else {\n                Ls[i][i] = 1 / this.s[i];\n            }\n        }\n\n        var U = this.U;\n        var V = this.rightSingularVectors;\n\n        var VL = V.mmul(Ls),\n            vrows = V.rows,\n            urows = U.length,\n            VLU = Matrix.Matrix.zeros(vrows, urows),\n            j, k, sum;\n\n        for (i = 0; i < vrows; i++) {\n            for (j = 0; j < urows; j++) {\n                sum = 0;\n                for (k = 0; k < scols; k++) {\n                    sum += VL[i][k] * U[j][k];\n                }\n                VLU[i][j] = sum;\n            }\n        }\n\n        return VLU.mmul(Y);\n    },\n    solveForDiagonal: function (value) {\n        return this.solve(Matrix.Matrix.diag(value));\n    },\n    inverse: function () {\n        var V = this.V;\n        var e = this.threshold,\n            vrows = V.length,\n            vcols = V[0].length,\n            X = new Matrix.Matrix(vrows, this.s.length),\n            i, j;\n\n        for (i = 0; i < vrows; i++) {\n            for (j = 0; j < vcols; j++) {\n                if (Math.abs(this.s[j]) > e) {\n                    X[i][j] = V[i][j] / this.s[j];\n                } else {\n                    X[i][j] = 0;\n                }\n            }\n        }\n\n        var U = this.U;\n\n        var urows = U.length,\n            ucols = U[0].length,\n            Y = new Matrix.Matrix(vrows, urows),\n            k, sum;\n\n        for (i = 0; i < vrows; i++) {\n            for (j = 0; j < urows; j++) {\n                sum = 0;\n                for (k = 0; k < ucols; k++) {\n                    sum += X[i][k] * U[j][k];\n                }\n                Y[i][j] = sum;\n            }\n        }\n\n        return Y;\n    }\n};\n\nmodule.exports = SingularValueDecomposition;\n","'use strict';\n\nconst Stat = require('ml-stat').array;\n/**\n * Function that returns an array of points given 1D array as follows:\n *\n * [x1, y1, .. , x2, y2, ..]\n *\n * And receive the number of dimensions of each point.\n * @param array\n * @param dimensions\n * @returns {Array} - Array of points.\n */\nfunction coordArrayToPoints(array, dimensions) {\n    if(array.length % dimensions !== 0) {\n        throw new RangeError('Dimensions number must be accordance with the size of the array.');\n    }\n\n    var length = array.length / dimensions;\n    var pointsArr = new Array(length);\n\n    var k = 0;\n    for(var i = 0; i < array.length; i += dimensions) {\n        var point = new Array(dimensions);\n        for(var j = 0; j < dimensions; ++j) {\n            point[j] = array[i + j];\n        }\n\n        pointsArr[k] = point;\n        k++;\n    }\n\n    return pointsArr;\n}\n\n\n/**\n * Function that given an array as follows:\n * [x1, y1, .. , x2, y2, ..]\n *\n * Returns an array as follows:\n * [[x1, x2, ..], [y1, y2, ..], [ .. ]]\n *\n * And receives the number of dimensions of each coordinate.\n * @param array\n * @param dimensions\n * @returns {Array} - Matrix of coordinates\n */\nfunction coordArrayToCoordMatrix(array, dimensions) {\n    if(array.length % dimensions !== 0) {\n        throw new RangeError('Dimensions number must be accordance with the size of the array.');\n    }\n\n    var coordinatesArray = new Array(dimensions);\n    var points = array.length / dimensions;\n    for (var i = 0; i < coordinatesArray.length; i++) {\n        coordinatesArray[i] = new Array(points);\n    }\n\n    for(i = 0; i < array.length; i += dimensions) {\n        for(var j = 0; j < dimensions; ++j) {\n            var currentPoint = Math.floor(i / dimensions);\n            coordinatesArray[j][currentPoint] = array[i + j];\n        }\n    }\n\n    return coordinatesArray;\n}\n\n/**\n * Function that receives a coordinate matrix as follows:\n * [[x1, x2, ..], [y1, y2, ..], [ .. ]]\n *\n * Returns an array of coordinates as follows:\n * [x1, y1, .. , x2, y2, ..]\n *\n * @param coordMatrix\n * @returns {Array}\n */\nfunction coordMatrixToCoordArray(coordMatrix) {\n    var coodinatesArray = new Array(coordMatrix.length * coordMatrix[0].length);\n    var k = 0;\n    for(var i = 0; i < coordMatrix[0].length; ++i) {\n        for(var j = 0; j < coordMatrix.length; ++j) {\n            coodinatesArray[k] = coordMatrix[j][i];\n            ++k;\n        }\n    }\n\n    return coodinatesArray;\n}\n\n/**\n * Tranpose a matrix, this method is for coordMatrixToPoints and\n * pointsToCoordMatrix, that because only transposing the matrix\n * you can change your representation.\n *\n * @param matrix\n * @returns {Array}\n */\nfunction transpose(matrix) {\n    var resultMatrix = new Array(matrix[0].length);\n    for(var i = 0; i < resultMatrix.length; ++i) {\n        resultMatrix[i] = new Array(matrix.length);\n    }\n\n    for (i = 0; i < matrix.length; ++i) {\n        for(var j = 0; j < matrix[0].length; ++j) {\n            resultMatrix[j][i] = matrix[i][j];\n        }\n    }\n\n    return resultMatrix;\n}\n\n/**\n * Function that transform an array of points into a coordinates array\n * as follows:\n * [x1, y1, .. , x2, y2, ..]\n *\n * @param points\n * @returns {Array}\n */\nfunction pointsToCoordArray(points) {\n    var coodinatesArray = new Array(points.length * points[0].length);\n    var k = 0;\n    for(var i = 0; i < points.length; ++i) {\n        for(var j = 0; j < points[0].length; ++j) {\n            coodinatesArray[k] = points[i][j];\n            ++k;\n        }\n    }\n\n    return coodinatesArray;\n}\n\n/**\n * Apply the dot product between the smaller vector and a subsets of the\n * largest one.\n *\n * @param firstVector\n * @param secondVector\n * @returns {Array} each dot product of size of the difference between the\n *                  larger and the smallest one.\n */\nfunction applyDotProduct(firstVector, secondVector) {\n    var largestVector, smallestVector;\n    if(firstVector.length <= secondVector.length) {\n        smallestVector = firstVector;\n        largestVector = secondVector;\n    } else {\n        smallestVector = secondVector;\n        largestVector = firstVector;\n    }\n\n    var difference = largestVector.length - smallestVector.length + 1;\n    var dotProductApplied = new Array(difference);\n\n    for (var i = 0; i < difference; ++i) {\n        var sum = 0;\n        for (var j = 0; j < smallestVector.length; ++j) {\n            sum += smallestVector[j] * largestVector[i + j];\n        }\n        dotProductApplied[i] = sum;\n    }\n\n    return dotProductApplied;\n}\n/**\n * To scale the input array between the specified min and max values. The operation is performed inplace\n * if the options.inplace is specified. If only one of the min or max parameters is specified, then the scaling\n * will multiply the input array by min/min(input) or max/max(input)\n * @param input\n * @param options\n * @returns {*}\n */\nfunction scale(input, options){\n    var y;\n    if(options.inPlace){\n        y = input;\n    }\n    else{\n        y = new Array(input.length);\n    }\n    const max = options.max;\n    const min = options.min;\n    if(typeof max === \"number\"){\n        if(typeof min === \"number\"){\n            var minMax = Stat.minMax(input);\n            var factor = (max - min)/(minMax.max-minMax.min);\n            for(var i=0;i< y.length;i++){\n                y[i]=(input[i]-minMax.min)*factor+min;\n            }\n        }\n        else{\n            var currentMin = Stat.max(input);\n            var factor = max/currentMin;\n            for(var i=0;i< y.length;i++){\n                y[i] = input[i]*factor;\n            }\n        }\n    }\n    else{\n        if(typeof min === \"number\"){\n            var currentMin = Stat.min(input);\n            var factor = min/currentMin;\n            for(var i=0;i< y.length;i++){\n                y[i] = input[i]*factor;\n            }\n        }\n    }\n    return y;\n}\n\nmodule.exports = {\n    coordArrayToPoints: coordArrayToPoints,\n    coordArrayToCoordMatrix: coordArrayToCoordMatrix,\n    coordMatrixToCoordArray: coordMatrixToCoordArray,\n    coordMatrixToPoints: transpose,\n    pointsToCoordArray: pointsToCoordArray,\n    pointsToCoordMatrix: transpose,\n    applyDotProduct: applyDotProduct,\n    scale:scale\n};\n\n","export default \"<ion-header>\\r\\n  <ion-toolbar>\\r\\n    <ion-title>employee-map</ion-title>\\r\\n  </ion-toolbar>\\r\\n</ion-header>\\r\\n\\r\\n<ion-content>\\r\\n  <div id=\\\"upload-component\\\">\\r\\n    <!-- <h1>Hello there</h1>\\r\\n\\r\\n    <div class=\\\"form-group\\\">\\r\\n      <input\\r\\n        #uuidMap\\r\\n        placeholder=\\\"Enter UUID\\\"\\r\\n        type=\\\"text\\\"\\r\\n        value=\\\"91bed1ff-4e7e-4380-abde-294b60499125\\\"\\r\\n      />\\r\\n      <ion-button (click)=\\\"handleSubmitClick(uuidMap.value)\\\">Submit</ion-button>\\r\\n    </div> -->\\r\\n\\r\\n    <ion-button (click)=\\\"getNearestExit()\\\">Get Nearest Exit</ion-button>\\r\\n    <ion-button (click)=\\\"getLocation()\\\">Get Location</ion-button>\\r\\n\\r\\n    <canvas id=\\\"mapFabricCanvas\\\"></canvas>\\r\\n\\r\\n    <ul *ngFor=\\\"let i of distArray\\\">\\r\\n      <li>{{i}}</li>\\r\\n    </ul>\\r\\n  </div>\\r\\n</ion-content>\\r\\n\";","'use strict';\n\nvar BaseView = require('./base');\n\nclass MatrixTransposeView extends BaseView {\n    constructor(matrix) {\n        super(matrix, matrix.columns, matrix.rows);\n    }\n\n    set(rowIndex, columnIndex, value) {\n        this.matrix.set(columnIndex, rowIndex, value);\n        return this;\n    }\n\n    get(rowIndex, columnIndex) {\n        return this.matrix.get(columnIndex, rowIndex);\n    }\n}\n\nmodule.exports = MatrixTransposeView;\n","'use strict';\n\nvar BaseView = require('./base');\nvar util = require('../util');\n\nclass MatrixSelectionView extends BaseView {\n    constructor(matrix, rowIndices, columnIndices) {\n        var indices = util.checkIndices(matrix, rowIndices, columnIndices);\n        super(matrix, indices.row.length, indices.column.length);\n        this.rowIndices = indices.row;\n        this.columnIndices = indices.column;\n    }\n\n    set(rowIndex, columnIndex, value) {\n        this.matrix.set(this.rowIndices[rowIndex], this.columnIndices[columnIndex], value);\n        return this;\n    }\n\n    get(rowIndex, columnIndex) {\n        return this.matrix.get(this.rowIndices[rowIndex], this.columnIndices[columnIndex]);\n    }\n}\n\nmodule.exports = MatrixSelectionView;\n","'use strict';\n\nvar abstractMatrix = require('../abstractMatrix');\nvar Matrix = require('../matrix');\n\nclass BaseView extends abstractMatrix() {\n    constructor(matrix, rows, columns) {\n        super();\n        this.matrix = matrix;\n        this.rows = rows;\n        this.columns = columns;\n    }\n\n    static get [Symbol.species]() {\n        return Matrix.Matrix;\n    }\n}\n\nmodule.exports = BaseView;\n","'use strict';\n\nvar arrayStat = require('./array');\n\nfunction compareNumbers(a, b) {\n    return a - b;\n}\n\nexports.max = function max(matrix) {\n    var max = -Infinity;\n    for (var i = 0; i < matrix.length; i++) {\n        for (var j = 0; j < matrix[i].length; j++) {\n            if (matrix[i][j] > max) max = matrix[i][j];\n        }\n    }\n    return max;\n};\n\nexports.min = function min(matrix) {\n    var min = Infinity;\n    for (var i = 0; i < matrix.length; i++) {\n        for (var j = 0; j < matrix[i].length; j++) {\n            if (matrix[i][j] < min) min = matrix[i][j];\n        }\n    }\n    return min;\n};\n\nexports.minMax = function minMax(matrix) {\n    var min = Infinity;\n    var max = -Infinity;\n    for (var i = 0; i < matrix.length; i++) {\n        for (var j = 0; j < matrix[i].length; j++) {\n            if (matrix[i][j] < min) min = matrix[i][j];\n            if (matrix[i][j] > max) max = matrix[i][j];\n        }\n    }\n    return {\n        min:min,\n        max:max\n    };\n};\n\nexports.entropy = function entropy(matrix, eps) {\n    if (typeof (eps) === 'undefined') {\n        eps = 0;\n    }\n    var sum = 0,\n        l1 = matrix.length,\n        l2 = matrix[0].length;\n    for (var i = 0; i < l1; i++) {\n        for (var j = 0; j < l2; j++) {\n            sum += matrix[i][j] * Math.log(matrix[i][j] + eps);\n        }\n    }\n    return -sum;\n};\n\nexports.mean = function mean(matrix, dimension) {\n    if (typeof (dimension) === 'undefined') {\n        dimension = 0;\n    }\n    var rows = matrix.length,\n        cols = matrix[0].length,\n        theMean, N, i, j;\n\n    if (dimension === -1) {\n        theMean = [0];\n        N = rows * cols;\n        for (i = 0; i < rows; i++) {\n            for (j = 0; j < cols; j++) {\n                theMean[0] += matrix[i][j];\n            }\n        }\n        theMean[0] /= N;\n    } else if (dimension === 0) {\n        theMean = new Array(cols);\n        N = rows;\n        for (j = 0; j < cols; j++) {\n            theMean[j] = 0;\n            for (i = 0; i < rows; i++) {\n                theMean[j] += matrix[i][j];\n            }\n            theMean[j] /= N;\n        }\n    } else if (dimension === 1) {\n        theMean = new Array(rows);\n        N = cols;\n        for (j = 0; j < rows; j++) {\n            theMean[j] = 0;\n            for (i = 0; i < cols; i++) {\n                theMean[j] += matrix[j][i];\n            }\n            theMean[j] /= N;\n        }\n    } else {\n        throw new Error('Invalid dimension');\n    }\n    return theMean;\n};\n\nexports.sum = function sum(matrix, dimension) {\n    if (typeof (dimension) === 'undefined') {\n        dimension = 0;\n    }\n    var rows = matrix.length,\n        cols = matrix[0].length,\n        theSum, i, j;\n\n    if (dimension === -1) {\n        theSum = [0];\n        for (i = 0; i < rows; i++) {\n            for (j = 0; j < cols; j++) {\n                theSum[0] += matrix[i][j];\n            }\n        }\n    } else if (dimension === 0) {\n        theSum = new Array(cols);\n        for (j = 0; j < cols; j++) {\n            theSum[j] = 0;\n            for (i = 0; i < rows; i++) {\n                theSum[j] += matrix[i][j];\n            }\n        }\n    } else if (dimension === 1) {\n        theSum = new Array(rows);\n        for (j = 0; j < rows; j++) {\n            theSum[j] = 0;\n            for (i = 0; i < cols; i++) {\n                theSum[j] += matrix[j][i];\n            }\n        }\n    } else {\n        throw new Error('Invalid dimension');\n    }\n    return theSum;\n};\n\nexports.product = function product(matrix, dimension) {\n    if (typeof (dimension) === 'undefined') {\n        dimension = 0;\n    }\n    var rows = matrix.length,\n        cols = matrix[0].length,\n        theProduct, i, j;\n\n    if (dimension === -1) {\n        theProduct = [1];\n        for (i = 0; i < rows; i++) {\n            for (j = 0; j < cols; j++) {\n                theProduct[0] *= matrix[i][j];\n            }\n        }\n    } else if (dimension === 0) {\n        theProduct = new Array(cols);\n        for (j = 0; j < cols; j++) {\n            theProduct[j] = 1;\n            for (i = 0; i < rows; i++) {\n                theProduct[j] *= matrix[i][j];\n            }\n        }\n    } else if (dimension === 1) {\n        theProduct = new Array(rows);\n        for (j = 0; j < rows; j++) {\n            theProduct[j] = 1;\n            for (i = 0; i < cols; i++) {\n                theProduct[j] *= matrix[j][i];\n            }\n        }\n    } else {\n        throw new Error('Invalid dimension');\n    }\n    return theProduct;\n};\n\nexports.standardDeviation = function standardDeviation(matrix, means, unbiased) {\n    var vari = exports.variance(matrix, means, unbiased), l = vari.length;\n    for (var i = 0; i < l; i++) {\n        vari[i] = Math.sqrt(vari[i]);\n    }\n    return vari;\n};\n\nexports.variance = function variance(matrix, means, unbiased) {\n    if (typeof (unbiased) === 'undefined') {\n        unbiased = true;\n    }\n    means = means || exports.mean(matrix);\n    var rows = matrix.length;\n    if (rows === 0) return [];\n    var cols = matrix[0].length;\n    var vari = new Array(cols);\n\n    for (var j = 0; j < cols; j++) {\n        var sum1 = 0, sum2 = 0, x = 0;\n        for (var i = 0; i < rows; i++) {\n            x = matrix[i][j] - means[j];\n            sum1 += x;\n            sum2 += x * x;\n        }\n        if (unbiased) {\n            vari[j] = (sum2 - ((sum1 * sum1) / rows)) / (rows - 1);\n        } else {\n            vari[j] = (sum2 - ((sum1 * sum1) / rows)) / rows;\n        }\n    }\n    return vari;\n};\n\nexports.median = function median(matrix) {\n    var rows = matrix.length, cols = matrix[0].length;\n    var medians = new Array(cols);\n\n    for (var i = 0; i < cols; i++) {\n        var data = new Array(rows);\n        for (var j = 0; j < rows; j++) {\n            data[j] = matrix[j][i];\n        }\n        data.sort(compareNumbers);\n        var N = data.length;\n        if (N % 2 === 0) {\n            medians[i] = (data[N / 2] + data[(N / 2) - 1]) * 0.5;\n        } else {\n            medians[i] = data[Math.floor(N / 2)];\n        }\n    }\n    return medians;\n};\n\nexports.mode = function mode(matrix) {\n    var rows = matrix.length,\n        cols = matrix[0].length,\n        modes = new Array(cols),\n        i, j;\n    for (i = 0; i < cols; i++) {\n        var itemCount = new Array(rows);\n        for (var k = 0; k < rows; k++) {\n            itemCount[k] = 0;\n        }\n        var itemArray = new Array(rows);\n        var count = 0;\n\n        for (j = 0; j < rows; j++) {\n            var index = itemArray.indexOf(matrix[j][i]);\n            if (index >= 0) {\n                itemCount[index]++;\n            } else {\n                itemArray[count] = matrix[j][i];\n                itemCount[count] = 1;\n                count++;\n            }\n        }\n\n        var maxValue = 0, maxIndex = 0;\n        for (j = 0; j < count; j++) {\n            if (itemCount[j] > maxValue) {\n                maxValue = itemCount[j];\n                maxIndex = j;\n            }\n        }\n\n        modes[i] = itemArray[maxIndex];\n    }\n    return modes;\n};\n\nexports.skewness = function skewness(matrix, unbiased) {\n    if (typeof (unbiased) === 'undefined') unbiased = true;\n    var means = exports.mean(matrix);\n    var n = matrix.length, l = means.length;\n    var skew = new Array(l);\n\n    for (var j = 0; j < l; j++) {\n        var s2 = 0, s3 = 0;\n        for (var i = 0; i < n; i++) {\n            var dev = matrix[i][j] - means[j];\n            s2 += dev * dev;\n            s3 += dev * dev * dev;\n        }\n\n        var m2 = s2 / n;\n        var m3 = s3 / n;\n        var g = m3 / Math.pow(m2, 3 / 2);\n\n        if (unbiased) {\n            var a = Math.sqrt(n * (n - 1));\n            var b = n - 2;\n            skew[j] = (a / b) * g;\n        } else {\n            skew[j] = g;\n        }\n    }\n    return skew;\n};\n\nexports.kurtosis = function kurtosis(matrix, unbiased) {\n    if (typeof (unbiased) === 'undefined') unbiased = true;\n    var means = exports.mean(matrix);\n    var n = matrix.length, m = matrix[0].length;\n    var kurt = new Array(m);\n\n    for (var j = 0; j < m; j++) {\n        var s2 = 0, s4 = 0;\n        for (var i = 0; i < n; i++) {\n            var dev = matrix[i][j] - means[j];\n            s2 += dev * dev;\n            s4 += dev * dev * dev * dev;\n        }\n        var m2 = s2 / n;\n        var m4 = s4 / n;\n\n        if (unbiased) {\n            var v = s2 / (n - 1);\n            var a = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));\n            var b = s4 / (v * v);\n            var c = ((n - 1) * (n - 1)) / ((n - 2) * (n - 3));\n            kurt[j] = a * b - 3 * c;\n        } else {\n            kurt[j] = m4 / (m2 * m2) - 3;\n        }\n    }\n    return kurt;\n};\n\nexports.standardError = function standardError(matrix) {\n    var samples = matrix.length;\n    var standardDeviations = exports.standardDeviation(matrix);\n    var l = standardDeviations.length;\n    var standardErrors = new Array(l);\n    var sqrtN = Math.sqrt(samples);\n\n    for (var i = 0; i < l; i++) {\n        standardErrors[i] = standardDeviations[i] / sqrtN;\n    }\n    return standardErrors;\n};\n\nexports.covariance = function covariance(matrix, dimension) {\n    return exports.scatter(matrix, undefined, dimension);\n};\n\nexports.scatter = function scatter(matrix, divisor, dimension) {\n    if (typeof (dimension) === 'undefined') {\n        dimension = 0;\n    }\n    if (typeof (divisor) === 'undefined') {\n        if (dimension === 0) {\n            divisor = matrix.length - 1;\n        } else if (dimension === 1) {\n            divisor = matrix[0].length - 1;\n        }\n    }\n    var means = exports.mean(matrix, dimension);\n    var rows = matrix.length;\n    if (rows === 0) {\n        return [[]];\n    }\n    var cols = matrix[0].length,\n        cov, i, j, s, k;\n\n    if (dimension === 0) {\n        cov = new Array(cols);\n        for (i = 0; i < cols; i++) {\n            cov[i] = new Array(cols);\n        }\n        for (i = 0; i < cols; i++) {\n            for (j = i; j < cols; j++) {\n                s = 0;\n                for (k = 0; k < rows; k++) {\n                    s += (matrix[k][j] - means[j]) * (matrix[k][i] - means[i]);\n                }\n                s /= divisor;\n                cov[i][j] = s;\n                cov[j][i] = s;\n            }\n        }\n    } else if (dimension === 1) {\n        cov = new Array(rows);\n        for (i = 0; i < rows; i++) {\n            cov[i] = new Array(rows);\n        }\n        for (i = 0; i < rows; i++) {\n            for (j = i; j < rows; j++) {\n                s = 0;\n                for (k = 0; k < cols; k++) {\n                    s += (matrix[j][k] - means[j]) * (matrix[i][k] - means[i]);\n                }\n                s /= divisor;\n                cov[i][j] = s;\n                cov[j][i] = s;\n            }\n        }\n    } else {\n        throw new Error('Invalid dimension');\n    }\n\n    return cov;\n};\n\nexports.correlation = function correlation(matrix) {\n    var means = exports.mean(matrix),\n        standardDeviations = exports.standardDeviation(matrix, true, means),\n        scores = exports.zScores(matrix, means, standardDeviations),\n        rows = matrix.length,\n        cols = matrix[0].length,\n        i, j;\n\n    var cor = new Array(cols);\n    for (i = 0; i < cols; i++) {\n        cor[i] = new Array(cols);\n    }\n    for (i = 0; i < cols; i++) {\n        for (j = i; j < cols; j++) {\n            var c = 0;\n            for (var k = 0, l = scores.length; k < l; k++) {\n                c += scores[k][j] * scores[k][i];\n            }\n            c /= rows - 1;\n            cor[i][j] = c;\n            cor[j][i] = c;\n        }\n    }\n    return cor;\n};\n\nexports.zScores = function zScores(matrix, means, standardDeviations) {\n    means = means || exports.mean(matrix);\n    if (typeof (standardDeviations) === 'undefined') standardDeviations = exports.standardDeviation(matrix, true, means);\n    return exports.standardize(exports.center(matrix, means, false), standardDeviations, true);\n};\n\nexports.center = function center(matrix, means, inPlace) {\n    means = means || exports.mean(matrix);\n    var result = matrix,\n        l = matrix.length,\n        i, j, jj;\n\n    if (!inPlace) {\n        result = new Array(l);\n        for (i = 0; i < l; i++) {\n            result[i] = new Array(matrix[i].length);\n        }\n    }\n\n    for (i = 0; i < l; i++) {\n        var row = result[i];\n        for (j = 0, jj = row.length; j < jj; j++) {\n            row[j] = matrix[i][j] - means[j];\n        }\n    }\n    return result;\n};\n\nexports.standardize = function standardize(matrix, standardDeviations, inPlace) {\n    if (typeof (standardDeviations) === 'undefined') standardDeviations = exports.standardDeviation(matrix);\n    var result = matrix,\n        l = matrix.length,\n        i, j, jj;\n\n    if (!inPlace) {\n        result = new Array(l);\n        for (i = 0; i < l; i++) {\n            result[i] = new Array(matrix[i].length);\n        }\n    }\n\n    for (i = 0; i < l; i++) {\n        var resultRow = result[i];\n        var sourceRow = matrix[i];\n        for (j = 0, jj = resultRow.length; j < jj; j++) {\n            if (standardDeviations[j] !== 0 && !isNaN(standardDeviations[j])) {\n                resultRow[j] = sourceRow[j] / standardDeviations[j];\n            }\n        }\n    }\n    return result;\n};\n\nexports.weightedVariance = function weightedVariance(matrix, weights) {\n    var means = exports.mean(matrix);\n    var rows = matrix.length;\n    if (rows === 0) return [];\n    var cols = matrix[0].length;\n    var vari = new Array(cols);\n\n    for (var j = 0; j < cols; j++) {\n        var sum = 0;\n        var a = 0, b = 0;\n\n        for (var i = 0; i < rows; i++) {\n            var z = matrix[i][j] - means[j];\n            var w = weights[i];\n\n            sum += w * (z * z);\n            b += w;\n            a += w * w;\n        }\n\n        vari[j] = sum * (b / (b * b - a));\n    }\n\n    return vari;\n};\n\nexports.weightedMean = function weightedMean(matrix, weights, dimension) {\n    if (typeof (dimension) === 'undefined') {\n        dimension = 0;\n    }\n    var rows = matrix.length;\n    if (rows === 0) return [];\n    var cols = matrix[0].length,\n        means, i, ii, j, w, row;\n\n    if (dimension === 0) {\n        means = new Array(cols);\n        for (i = 0; i < cols; i++) {\n            means[i] = 0;\n        }\n        for (i = 0; i < rows; i++) {\n            row = matrix[i];\n            w = weights[i];\n            for (j = 0; j < cols; j++) {\n                means[j] += row[j] * w;\n            }\n        }\n    } else if (dimension === 1) {\n        means = new Array(rows);\n        for (i = 0; i < rows; i++) {\n            means[i] = 0;\n        }\n        for (j = 0; j < rows; j++) {\n            row = matrix[j];\n            w = weights[j];\n            for (i = 0; i < cols; i++) {\n                means[j] += row[i] * w;\n            }\n        }\n    } else {\n        throw new Error('Invalid dimension');\n    }\n\n    var weightSum = arrayStat.sum(weights);\n    if (weightSum !== 0) {\n        for (i = 0, ii = means.length; i < ii; i++) {\n            means[i] /= weightSum;\n        }\n    }\n    return means;\n};\n\nexports.weightedCovariance = function weightedCovariance(matrix, weights, means, dimension) {\n    dimension = dimension || 0;\n    means = means || exports.weightedMean(matrix, weights, dimension);\n    var s1 = 0, s2 = 0;\n    for (var i = 0, ii = weights.length; i < ii; i++) {\n        s1 += weights[i];\n        s2 += weights[i] * weights[i];\n    }\n    var factor = s1 / (s1 * s1 - s2);\n    return exports.weightedScatter(matrix, weights, means, factor, dimension);\n};\n\nexports.weightedScatter = function weightedScatter(matrix, weights, means, factor, dimension) {\n    dimension = dimension || 0;\n    means = means || exports.weightedMean(matrix, weights, dimension);\n    if (typeof (factor) === 'undefined') {\n        factor = 1;\n    }\n    var rows = matrix.length;\n    if (rows === 0) {\n        return [[]];\n    }\n    var cols = matrix[0].length,\n        cov, i, j, k, s;\n\n    if (dimension === 0) {\n        cov = new Array(cols);\n        for (i = 0; i < cols; i++) {\n            cov[i] = new Array(cols);\n        }\n        for (i = 0; i < cols; i++) {\n            for (j = i; j < cols; j++) {\n                s = 0;\n                for (k = 0; k < rows; k++) {\n                    s += weights[k] * (matrix[k][j] - means[j]) * (matrix[k][i] - means[i]);\n                }\n                cov[i][j] = s * factor;\n                cov[j][i] = s * factor;\n            }\n        }\n    } else if (dimension === 1) {\n        cov = new Array(rows);\n        for (i = 0; i < rows; i++) {\n            cov[i] = new Array(rows);\n        }\n        for (i = 0; i < rows; i++) {\n            for (j = i; j < rows; j++) {\n                s = 0;\n                for (k = 0; k < cols; k++) {\n                    s += weights[k] * (matrix[j][k] - means[j]) * (matrix[i][k] - means[i]);\n                }\n                cov[i][j] = s * factor;\n                cov[j][i] = s * factor;\n            }\n        }\n    } else {\n        throw new Error('Invalid dimension');\n    }\n\n    return cov;\n};\n","'use strict';\n\nexports.array = require('./array');\nexports.matrix = require('./matrix');\n","var LM = require('ml-curve-fitting');\nvar Matrix = LM.Matrix;\nvar math = Matrix.algebra;\n\n\n\n//Distance function. p is the guessed point.\nvar euclidean = function(t,p,c){\n    var rows = t.rows;\n    var result = new Matrix(t.rows, 1);\n    for(var i=0;i<rows;i++){\n       result[i][0] = Math.sqrt(Math.pow(t[i][0]-p[0][0],2)+Math.pow(t[i][1]-p[1][0],2));\n    }\n\n    return result;\n};\n\n\n\n// var data =  [[0.0, 0.0, 10.0], [10.0, 10.0, 10], [10.0, 0.0, 14.142135]];\n\n\n\n/*\n * Data should be an array of 3 3-sized arrays with [x, y, dist]\n * Example follows...\n * Input:\n * [\n *  [ 0.0,  0.0, 10.0],\n *  [10.0, 10.0, 10.0],\n *  [10.0,  0.0, 14.142135]\n * ]\n *\n * Output:\n *\n */\n\nfunction trilat(data, allowedDist) {\n    var nbPoints = data.length;\n    var t = math.matrix(nbPoints,2);//[1:Npnt]'; // independent variable\n    var y_data = math.matrix(nbPoints, 1);\n\n    for(var i=0;i<nbPoints;i++){\n        t[i][0] = data[i][0];\n        t[i][1] = data[i][1];\n        y_data[i][0] = data[i][2];\n    }\n\n    var weight = [1];\n    var opts = [ 2, 100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2, 11, 9, 1 ];\n    var consts = [];\n    \n    var Xs = [ data[0][0], data[1][0], data[2][0] ];\n    var Ys = [ data[0][1], data[1][1], data[2][1] ];\n    var minX = Math.min.apply(Math, Xs);\n    var minY = Math.min.apply(Math, Ys);\n    var maxX = Math.max.apply(Math, Xs);\n    var maxY = Math.max.apply(Math, Ys);\n    var avgX = ( Xs[0] + Xs[1] + Xs[2] ) / 3;\n    var avgY = ( Ys[0] + Ys[1] + Ys[2] ) / 3;\n    var ad = allowedDist || 0;\n    \n    var p_init = math.matrix([[avgX], [avgY]]);\n    var p_min = math.matrix([[minX-ad], [minY-ad]]);\n    var p_max = math.matrix([[maxX+ad], [maxY-ad]]);\n    \n    // https://github.com/mljs/curve-fitting/blob/master/Documentation.md\n    var p_fit = LM.optimize(euclidean,p_init,t,y_data,weight,-0.01,p_min,p_max,consts,opts);\n    p_fit = p_fit.p;\n    \n    // euclidean(t,p_fit,consts)\n    \n    return [ p_fit[0][0], p_fit[1][0] ];\n}\n\nmodule.exports = trilat;\n","'use strict';\n\nmodule.exports = abstractMatrix;\n\nvar LuDecomposition = require('./dc/lu');\nvar SvDecomposition = require('./dc/svd');\nvar arrayUtils = require('ml-array-utils');\nvar util = require('./util');\nvar MatrixTransposeView = require('./views/transpose');\nvar MatrixRowView = require('./views/row');\nvar MatrixSubView = require('./views/sub');\nvar MatrixSelectionView = require('./views/selection');\nvar MatrixColumnView = require('./views/column');\nvar MatrixFlipRowView = require('./views/flipRow');\nvar MatrixFlipColumnView = require('./views/flipColumn');\n\nfunction abstractMatrix(superCtor) {\n    if (superCtor === undefined) superCtor = Object;\n\n    /**\n     * Real matrix\n     * @class Matrix\n     * @param {number|Array|Matrix} nRows - Number of rows of the new matrix,\n     * 2D array containing the data or Matrix instance to clone\n     * @param {number} [nColumns] - Number of columns of the new matrix\n     */\n    class Matrix extends superCtor {\n        static get [Symbol.species]() {\n            return this;\n        }\n\n        /**\n         * Constructs a Matrix with the chosen dimensions from a 1D array\n         * @param {number} newRows - Number of rows\n         * @param {number} newColumns - Number of columns\n         * @param {Array} newData - A 1D array containing data for the matrix\n         * @return {Matrix} - The new matrix\n         */\n        static from1DArray(newRows, newColumns, newData) {\n            var length = newRows * newColumns;\n            if (length !== newData.length) {\n                throw new RangeError('Data length does not match given dimensions');\n            }\n            var newMatrix = new this(newRows, newColumns);\n            for (var row = 0; row < newRows; row++) {\n                for (var column = 0; column < newColumns; column++) {\n                    newMatrix.set(row, column, newData[row * newColumns + column]);\n                }\n            }\n            return newMatrix;\n        }\n\n        /**\n         * Creates a row vector, a matrix with only one row.\n         * @param {Array} newData - A 1D array containing data for the vector\n         * @return {Matrix} - The new matrix\n         */\n        static rowVector(newData) {\n            var vector = new this(1, newData.length);\n            for (var i = 0; i < newData.length; i++) {\n                vector.set(0, i, newData[i]);\n            }\n            return vector;\n        }\n\n        /**\n         * Creates a column vector, a matrix with only one column.\n         * @param {Array} newData - A 1D array containing data for the vector\n         * @return {Matrix} - The new matrix\n         */\n        static columnVector(newData) {\n            var vector = new this(newData.length, 1);\n            for (var i = 0; i < newData.length; i++) {\n                vector.set(i, 0, newData[i]);\n            }\n            return vector;\n        }\n\n        /**\n         * Creates an empty matrix with the given dimensions. Values will be undefined. Same as using new Matrix(rows, columns).\n         * @param {number} rows - Number of rows\n         * @param {number} columns - Number of columns\n         * @return {Matrix} - The new matrix\n         */\n        static empty(rows, columns) {\n            return new this(rows, columns);\n        }\n\n        /**\n         * Creates a matrix with the given dimensions. Values will be set to zero.\n         * @param {number} rows - Number of rows\n         * @param {number} columns - Number of columns\n         * @return {Matrix} - The new matrix\n         */\n        static zeros(rows, columns) {\n            return this.empty(rows, columns).fill(0);\n        }\n\n        /**\n         * Creates a matrix with the given dimensions. Values will be set to one.\n         * @param {number} rows - Number of rows\n         * @param {number} columns - Number of columns\n         * @return {Matrix} - The new matrix\n         */\n        static ones(rows, columns) {\n            return this.empty(rows, columns).fill(1);\n        }\n\n        /**\n         * Creates a matrix with the given dimensions. Values will be randomly set.\n         * @param {number} rows - Number of rows\n         * @param {number} columns - Number of columns\n         * @param {function} [rng=Math.random] - Random number generator\n         * @return {Matrix} The new matrix\n         */\n        static rand(rows, columns, rng) {\n            if (rng === undefined) rng = Math.random;\n            var matrix = this.empty(rows, columns);\n            for (var i = 0; i < rows; i++) {\n                for (var j = 0; j < columns; j++) {\n                    matrix.set(i, j, rng());\n                }\n            }\n            return matrix;\n        }\n\n        /**\n         * Creates a matrix with the given dimensions. Values will be random integers.\n         * @param {number} rows - Number of rows\n         * @param {number} columns - Number of columns\n         * @param {number} [maxValue=1000] - Maximum value\n         * @param {function} [rng=Math.random] - Random number generator\n         * @return {Matrix} The new matrix\n         */\n        static randInt(rows, columns, maxValue, rng) {\n            if (maxValue === undefined) maxValue = 1000;\n            if (rng === undefined) rng = Math.random;\n            var matrix = this.empty(rows, columns);\n            for (var i = 0; i < rows; i++) {\n                for (var j = 0; j < columns; j++) {\n                    var value = Math.floor(rng() * maxValue);\n                    matrix.set(i, j, value);\n                }\n            }\n            return matrix;\n        }\n\n        /**\n         * Creates an identity matrix with the given dimension. Values of the diagonal will be 1 and others will be 0.\n         * @param {number} rows - Number of rows\n         * @param {number} [columns=rows] - Number of columns\n         * @param {number} [value=1] - Value to fill the diagonal with\n         * @return {Matrix} - The new identity matrix\n         */\n        static eye(rows, columns, value) {\n            if (columns === undefined) columns = rows;\n            if (value === undefined) value = 1;\n            var min = Math.min(rows, columns);\n            var matrix = this.zeros(rows, columns);\n            for (var i = 0; i < min; i++) {\n                matrix.set(i, i, value);\n            }\n            return matrix;\n        }\n\n        /**\n         * Creates a diagonal matrix based on the given array.\n         * @param {Array} data - Array containing the data for the diagonal\n         * @param {number} [rows] - Number of rows (Default: data.length)\n         * @param {number} [columns] - Number of columns (Default: rows)\n         * @return {Matrix} - The new diagonal matrix\n         */\n        static diag(data, rows, columns) {\n            var l = data.length;\n            if (rows === undefined) rows = l;\n            if (columns === undefined) columns = rows;\n            var min = Math.min(l, rows, columns);\n            var matrix = this.zeros(rows, columns);\n            for (var i = 0; i < min; i++) {\n                matrix.set(i, i, data[i]);\n            }\n            return matrix;\n        }\n\n        /**\n         * Returns a matrix whose elements are the minimum between matrix1 and matrix2\n         * @param {Matrix} matrix1\n         * @param {Matrix} matrix2\n         * @return {Matrix}\n         */\n        static min(matrix1, matrix2) {\n            matrix1 = this.checkMatrix(matrix1);\n            matrix2 = this.checkMatrix(matrix2);\n            var rows = matrix1.rows;\n            var columns = matrix1.columns;\n            var result = new this(rows, columns);\n            for (var i = 0; i < rows; i++) {\n                for (var j = 0; j < columns; j++) {\n                    result.set(i, j, Math.min(matrix1.get(i, j), matrix2.get(i, j)));\n                }\n            }\n            return result;\n        }\n\n        /**\n         * Returns a matrix whose elements are the maximum between matrix1 and matrix2\n         * @param {Matrix} matrix1\n         * @param {Matrix} matrix2\n         * @return {Matrix}\n         */\n        static max(matrix1, matrix2) {\n            matrix1 = this.checkMatrix(matrix1);\n            matrix2 = this.checkMatrix(matrix2);\n            var rows = matrix1.rows;\n            var columns = matrix1.columns;\n            var result = new this(rows, columns);\n            for (var i = 0; i < rows; i++) {\n                for (var j = 0; j < columns; j++) {\n                    result.set(i, j, Math.max(matrix1.get(i, j), matrix2.get(i, j)));\n                }\n            }\n            return result;\n        }\n\n        /**\n         * Check that the provided value is a Matrix and tries to instantiate one if not\n         * @param {*} value - The value to check\n         * @return {Matrix}\n         */\n        static checkMatrix(value) {\n            return Matrix.isMatrix(value) ? value : new this(value);\n        }\n\n        /**\n         * Returns true if the argument is a Matrix, false otherwise\n         * @param {*} value - The value to check\n         * @return {boolean}\n         */\n        static isMatrix(value) {\n            return (value != null) && (value.klass === 'Matrix');\n        }\n\n        /**\n         * @prop {number} size - The number of elements in the matrix.\n         */\n        get size() {\n            return this.rows * this.columns;\n        }\n\n        /**\n         * Applies a callback for each element of the matrix. The function is called in the matrix (this) context.\n         * @param {function} callback - Function that will be called with two parameters : i (row) and j (column)\n         * @return {Matrix} this\n         */\n        apply(callback) {\n            if (typeof callback !== 'function') {\n                throw new TypeError('callback must be a function');\n            }\n            var ii = this.rows;\n            var jj = this.columns;\n            for (var i = 0; i < ii; i++) {\n                for (var j = 0; j < jj; j++) {\n                    callback.call(this, i, j);\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Returns a new 1D array filled row by row with the matrix values\n         * @return {Array}\n         */\n        to1DArray() {\n            var array = new Array(this.size);\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    array[i * this.columns + j] = this.get(i, j);\n                }\n            }\n            return array;\n        }\n\n        /**\n         * Returns a 2D array containing a copy of the data\n         * @return {Array}\n         */\n        to2DArray() {\n            var copy = new Array(this.rows);\n            for (var i = 0; i < this.rows; i++) {\n                copy[i] = new Array(this.columns);\n                for (var j = 0; j < this.columns; j++) {\n                    copy[i][j] = this.get(i, j);\n                }\n            }\n            return copy;\n        }\n\n        /**\n         * @return {boolean} true if the matrix has one row\n         */\n        isRowVector() {\n            return this.rows === 1;\n        }\n\n        /**\n         * @return {boolean} true if the matrix has one column\n         */\n        isColumnVector() {\n            return this.columns === 1;\n        }\n\n        /**\n         * @return {boolean} true if the matrix has one row or one column\n         */\n        isVector() {\n            return (this.rows === 1) || (this.columns === 1);\n        }\n\n        /**\n         * @return {boolean} true if the matrix has the same number of rows and columns\n         */\n        isSquare() {\n            return this.rows === this.columns;\n        }\n\n        /**\n         * @return {boolean} true if the matrix is square and has the same values on both sides of the diagonal\n         */\n        isSymmetric() {\n            if (this.isSquare()) {\n                for (var i = 0; i < this.rows; i++) {\n                    for (var j = 0; j <= i; j++) {\n                        if (this.get(i, j) !== this.get(j, i)) {\n                            return false;\n                        }\n                    }\n                }\n                return true;\n            }\n            return false;\n        }\n\n        /**\n         * Sets a given element of the matrix. mat.set(3,4,1) is equivalent to mat[3][4]=1\n         * @abstract\n         * @param {number} rowIndex - Index of the row\n         * @param {number} columnIndex - Index of the column\n         * @param {number} value - The new value for the element\n         * @return {Matrix} this\n         */\n        set(rowIndex, columnIndex, value) { // eslint-disable-line no-unused-vars\n            throw new Error('set method is unimplemented');\n        }\n\n        /**\n         * Returns the given element of the matrix. mat.get(3,4) is equivalent to matrix[3][4]\n         * @abstract\n         * @param {number} rowIndex - Index of the row\n         * @param {number} columnIndex - Index of the column\n         * @return {number}\n         */\n        get(rowIndex, columnIndex) { // eslint-disable-line no-unused-vars\n            throw new Error('get method is unimplemented');\n        }\n\n        /**\n         * Creates a new matrix that is a repetition of the current matrix. New matrix has rowRep times the number of\n         * rows of the matrix, and colRep times the number of columns of the matrix\n         * @param {number} rowRep - Number of times the rows should be repeated\n         * @param {number} colRep - Number of times the columns should be re\n         * @return {Matrix}\n         * @example\n         * var matrix = new Matrix([[1,2]]);\n         * matrix.repeat(2); // [[1,2],[1,2]]\n         */\n        repeat(rowRep, colRep) {\n            rowRep = rowRep || 1;\n            colRep = colRep || 1;\n            var matrix = new this.constructor[Symbol.species](this.rows * rowRep, this.columns * colRep);\n            for (var i = 0; i < rowRep; i++) {\n                for (var j = 0; j < colRep; j++) {\n                    matrix.setSubMatrix(this, this.rows * i, this.columns * j);\n                }\n            }\n            return matrix;\n        }\n\n        /**\n         * Fills the matrix with a given value. All elements will be set to this value.\n         * @param {number} value - New value\n         * @return {Matrix} this\n         */\n        fill(value) {\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    this.set(i, j, value);\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Negates the matrix. All elements will be multiplied by (-1)\n         * @return {Matrix} this\n         */\n        neg() {\n            return this.mulS(-1);\n        }\n\n        /**\n         * Returns a new array from the given row index\n         * @param {number} index - Row index\n         * @return {Array}\n         */\n        getRow(index) {\n            util.checkRowIndex(this, index);\n            var row = new Array(this.columns);\n            for (var i = 0; i < this.columns; i++) {\n                row[i] = this.get(index, i);\n            }\n            return row;\n        }\n\n        /**\n         * Returns a new row vector from the given row index\n         * @param {number} index - Row index\n         * @return {Matrix}\n         */\n        getRowVector(index) {\n            return this.constructor.rowVector(this.getRow(index));\n        }\n\n        /**\n         * Sets a row at the given index\n         * @param {number} index - Row index\n         * @param {Array|Matrix} array - Array or vector\n         * @return {Matrix} this\n         */\n        setRow(index, array) {\n            util.checkRowIndex(this, index);\n            array = util.checkRowVector(this, array);\n            for (var i = 0; i < this.columns; i++) {\n                this.set(index, i, array[i]);\n            }\n            return this;\n        }\n\n        /**\n         * Swaps two rows\n         * @param {number} row1 - First row index\n         * @param {number} row2 - Second row index\n         * @return {Matrix} this\n         */\n        swapRows(row1, row2) {\n            util.checkRowIndex(this, row1);\n            util.checkRowIndex(this, row2);\n            for (var i = 0; i < this.columns; i++) {\n                var temp = this.get(row1, i);\n                this.set(row1, i, this.get(row2, i));\n                this.set(row2, i, temp);\n            }\n            return this;\n        }\n\n        /**\n         * Returns a new array from the given column index\n         * @param {number} index - Column index\n         * @return {Array}\n         */\n        getColumn(index) {\n            util.checkColumnIndex(this, index);\n            var column = new Array(this.rows);\n            for (var i = 0; i < this.rows; i++) {\n                column[i] = this.get(i, index);\n            }\n            return column;\n        }\n\n        /**\n         * Returns a new column vector from the given column index\n         * @param {number} index - Column index\n         * @return {Matrix}\n         */\n        getColumnVector(index) {\n            return this.constructor.columnVector(this.getColumn(index));\n        }\n\n        /**\n         * Sets a column at the given index\n         * @param {number} index - Column index\n         * @param {Array|Matrix} array - Array or vector\n         * @return {Matrix} this\n         */\n        setColumn(index, array) {\n            util.checkColumnIndex(this, index);\n            array = util.checkColumnVector(this, array);\n            for (var i = 0; i < this.rows; i++) {\n                this.set(i, index, array[i]);\n            }\n            return this;\n        }\n\n        /**\n         * Swaps two columns\n         * @param {number} column1 - First column index\n         * @param {number} column2 - Second column index\n         * @return {Matrix} this\n         */\n        swapColumns(column1, column2) {\n            util.checkColumnIndex(this, column1);\n            util.checkColumnIndex(this, column2);\n            for (var i = 0; i < this.rows; i++) {\n                var temp = this.get(i, column1);\n                this.set(i, column1, this.get(i, column2));\n                this.set(i, column2, temp);\n            }\n            return this;\n        }\n\n        /**\n         * Adds the values of a vector to each row\n         * @param {Array|Matrix} vector - Array or vector\n         * @return {Matrix} this\n         */\n        addRowVector(vector) {\n            vector = util.checkRowVector(this, vector);\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    this.set(i, j, this.get(i, j) + vector[j]);\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Subtracts the values of a vector from each row\n         * @param {Array|Matrix} vector - Array or vector\n         * @return {Matrix} this\n         */\n        subRowVector(vector) {\n            vector = util.checkRowVector(this, vector);\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    this.set(i, j, this.get(i, j) - vector[j]);\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Multiplies the values of a vector with each row\n         * @param {Array|Matrix} vector - Array or vector\n         * @return {Matrix} this\n         */\n        mulRowVector(vector) {\n            vector = util.checkRowVector(this, vector);\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    this.set(i, j, this.get(i, j) * vector[j]);\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Divides the values of each row by those of a vector\n         * @param {Array|Matrix} vector - Array or vector\n         * @return {Matrix} this\n         */\n        divRowVector(vector) {\n            vector = util.checkRowVector(this, vector);\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    this.set(i, j, this.get(i, j) / vector[j]);\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Adds the values of a vector to each column\n         * @param {Array|Matrix} vector - Array or vector\n         * @return {Matrix} this\n         */\n        addColumnVector(vector) {\n            vector = util.checkColumnVector(this, vector);\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    this.set(i, j, this.get(i, j) + vector[i]);\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Subtracts the values of a vector from each column\n         * @param {Array|Matrix} vector - Array or vector\n         * @return {Matrix} this\n         */\n        subColumnVector(vector) {\n            vector = util.checkColumnVector(this, vector);\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    this.set(i, j, this.get(i, j) - vector[i]);\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Multiplies the values of a vector with each column\n         * @param {Array|Matrix} vector - Array or vector\n         * @return {Matrix} this\n         */\n        mulColumnVector(vector) {\n            vector = util.checkColumnVector(this, vector);\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    this.set(i, j, this.get(i, j) * vector[i]);\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Divides the values of each column by those of a vector\n         * @param {Array|Matrix} vector - Array or vector\n         * @return {Matrix} this\n         */\n        divColumnVector(vector) {\n            vector = util.checkColumnVector(this, vector);\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    this.set(i, j, this.get(i, j) / vector[i]);\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Multiplies the values of a row with a scalar\n         * @param {number} index - Row index\n         * @param {number} value\n         * @return {Matrix} this\n         */\n        mulRow(index, value) {\n            util.checkRowIndex(this, index);\n            for (var i = 0; i < this.columns; i++) {\n                this.set(index, i, this.get(index, i) * value);\n            }\n            return this;\n        }\n\n        /**\n         * Multiplies the values of a column with a scalar\n         * @param {number} index - Column index\n         * @param {number} value\n         * @return {Matrix} this\n         */\n        mulColumn(index, value) {\n            util.checkColumnIndex(this, index);\n            for (var i = 0; i < this.rows; i++) {\n                this.set(i, index, this.get(i, index) * value);\n            }\n            return this;\n        }\n\n        /**\n         * Returns the maximum value of the matrix\n         * @return {number}\n         */\n        max() {\n            var v = this.get(0, 0);\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    if (this.get(i, j) > v) {\n                        v = this.get(i, j);\n                    }\n                }\n            }\n            return v;\n        }\n\n        /**\n         * Returns the index of the maximum value\n         * @return {Array}\n         */\n        maxIndex() {\n            var v = this.get(0, 0);\n            var idx = [0, 0];\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    if (this.get(i, j) > v) {\n                        v = this.get(i, j);\n                        idx[0] = i;\n                        idx[1] = j;\n                    }\n                }\n            }\n            return idx;\n        }\n\n        /**\n         * Returns the minimum value of the matrix\n         * @return {number}\n         */\n        min() {\n            var v = this.get(0, 0);\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    if (this.get(i, j) < v) {\n                        v = this.get(i, j);\n                    }\n                }\n            }\n            return v;\n        }\n\n        /**\n         * Returns the index of the minimum value\n         * @return {Array}\n         */\n        minIndex() {\n            var v = this.get(0, 0);\n            var idx = [0, 0];\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    if (this.get(i, j) < v) {\n                        v = this.get(i, j);\n                        idx[0] = i;\n                        idx[1] = j;\n                    }\n                }\n            }\n            return idx;\n        }\n\n        /**\n         * Returns the maximum value of one row\n         * @param {number} row - Row index\n         * @return {number}\n         */\n        maxRow(row) {\n            util.checkRowIndex(this, row);\n            var v = this.get(row, 0);\n            for (var i = 1; i < this.columns; i++) {\n                if (this.get(row, i) > v) {\n                    v = this.get(row, i);\n                }\n            }\n            return v;\n        }\n\n        /**\n         * Returns the index of the maximum value of one row\n         * @param {number} row - Row index\n         * @return {Array}\n         */\n        maxRowIndex(row) {\n            util.checkRowIndex(this, row);\n            var v = this.get(row, 0);\n            var idx = [row, 0];\n            for (var i = 1; i < this.columns; i++) {\n                if (this.get(row, i) > v) {\n                    v = this.get(row, i);\n                    idx[1] = i;\n                }\n            }\n            return idx;\n        }\n\n        /**\n         * Returns the minimum value of one row\n         * @param {number} row - Row index\n         * @return {number}\n         */\n        minRow(row) {\n            util.checkRowIndex(this, row);\n            var v = this.get(row, 0);\n            for (var i = 1; i < this.columns; i++) {\n                if (this.get(row, i) < v) {\n                    v = this.get(row, i);\n                }\n            }\n            return v;\n        }\n\n        /**\n         * Returns the index of the maximum value of one row\n         * @param {number} row - Row index\n         * @return {Array}\n         */\n        minRowIndex(row) {\n            util.checkRowIndex(this, row);\n            var v = this.get(row, 0);\n            var idx = [row, 0];\n            for (var i = 1; i < this.columns; i++) {\n                if (this.get(row, i) < v) {\n                    v = this.get(row, i);\n                    idx[1] = i;\n                }\n            }\n            return idx;\n        }\n\n        /**\n         * Returns the maximum value of one column\n         * @param {number} column - Column index\n         * @return {number}\n         */\n        maxColumn(column) {\n            util.checkColumnIndex(this, column);\n            var v = this.get(0, column);\n            for (var i = 1; i < this.rows; i++) {\n                if (this.get(i, column) > v) {\n                    v = this.get(i, column);\n                }\n            }\n            return v;\n        }\n\n        /**\n         * Returns the index of the maximum value of one column\n         * @param {number} column - Column index\n         * @return {Array}\n         */\n        maxColumnIndex(column) {\n            util.checkColumnIndex(this, column);\n            var v = this.get(0, column);\n            var idx = [0, column];\n            for (var i = 1; i < this.rows; i++) {\n                if (this.get(i, column) > v) {\n                    v = this.get(i, column);\n                    idx[0] = i;\n                }\n            }\n            return idx;\n        }\n\n        /**\n         * Returns the minimum value of one column\n         * @param {number} column - Column index\n         * @return {number}\n         */\n        minColumn(column) {\n            util.checkColumnIndex(this, column);\n            var v = this.get(0, column);\n            for (var i = 1; i < this.rows; i++) {\n                if (this.get(i, column) < v) {\n                    v = this.get(i, column);\n                }\n            }\n            return v;\n        }\n\n        /**\n         * Returns the index of the minimum value of one column\n         * @param {number} column - Column index\n         * @return {Array}\n         */\n        minColumnIndex(column) {\n            util.checkColumnIndex(this, column);\n            var v = this.get(0, column);\n            var idx = [0, column];\n            for (var i = 1; i < this.rows; i++) {\n                if (this.get(i, column) < v) {\n                    v = this.get(i, column);\n                    idx[0] = i;\n                }\n            }\n            return idx;\n        }\n\n        /**\n         * Returns an array containing the diagonal values of the matrix\n         * @return {Array}\n         */\n        diag() {\n            var min = Math.min(this.rows, this.columns);\n            var diag = new Array(min);\n            for (var i = 0; i < min; i++) {\n                diag[i] = this.get(i, i);\n            }\n            return diag;\n        }\n\n        /**\n         * Returns the sum by the argument given, if no argument given,\n         * it returns the sum of all elements of the matrix.\n         * @param {string} by - sum by 'row' or 'column'.\n         * @return {Matrix|number}\n         */\n        sum(by) {\n            switch (by) {\n                case 'row':\n                    return util.sumByRow(this);\n                case 'column':\n                    return util.sumByColumn(this);\n                default:\n                    return util.sumAll(this);\n            }\n        }\n\n        /**\n         * Returns the mean of all elements of the matrix\n         * @return {number}\n         */\n        mean() {\n            return this.sum() / this.size;\n        }\n\n        /**\n         * Returns the product of all elements of the matrix\n         * @return {number}\n         */\n        prod() {\n            var prod = 1;\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    prod *= this.get(i, j);\n                }\n            }\n            return prod;\n        }\n\n        /**\n         * Computes the cumulative sum of the matrix elements (in place, row by row)\n         * @return {Matrix} this\n         */\n        cumulativeSum() {\n            var sum = 0;\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    sum += this.get(i, j);\n                    this.set(i, j, sum);\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Computes the dot (scalar) product between the matrix and another\n         * @param {Matrix} vector2 vector\n         * @return {number}\n         */\n        dot(vector2) {\n            if (Matrix.isMatrix(vector2)) vector2 = vector2.to1DArray();\n            var vector1 = this.to1DArray();\n            if (vector1.length !== vector2.length) {\n                throw new RangeError('vectors do not have the same size');\n            }\n            var dot = 0;\n            for (var i = 0; i < vector1.length; i++) {\n                dot += vector1[i] * vector2[i];\n            }\n            return dot;\n        }\n\n        /**\n         * Returns the matrix product between this and other\n         * @param {Matrix} other\n         * @return {Matrix}\n         */\n        mmul(other) {\n            other = this.constructor.checkMatrix(other);\n            if (this.columns !== other.rows) {\n                // eslint-disable-next-line no-console\n                console.warn('Number of columns of left matrix are not equal to number of rows of right matrix.');\n            }\n\n            var m = this.rows;\n            var n = this.columns;\n            var p = other.columns;\n\n            var result = new this.constructor[Symbol.species](m, p);\n\n            var Bcolj = new Array(n);\n            for (var j = 0; j < p; j++) {\n                for (var k = 0; k < n; k++) {\n                    Bcolj[k] = other.get(k, j);\n                }\n\n                for (var i = 0; i < m; i++) {\n                    var s = 0;\n                    for (k = 0; k < n; k++) {\n                        s += this.get(i, k) * Bcolj[k];\n                    }\n\n                    result.set(i, j, s);\n                }\n            }\n            return result;\n        }\n\n        strassen2x2(other) {\n            var result = new this.constructor[Symbol.species](2, 2);\n            const a11 = this.get(0, 0);\n            const b11 = other.get(0, 0);\n            const a12 = this.get(0, 1);\n            const b12 = other.get(0, 1);\n            const a21 = this.get(1, 0);\n            const b21 = other.get(1, 0);\n            const a22 = this.get(1, 1);\n            const b22 = other.get(1, 1);\n\n            // Compute intermediate values.\n            const m1 = (a11 + a22) * (b11 + b22);\n            const m2 = (a21 + a22) * b11;\n            const m3 = a11 * (b12 - b22);\n            const m4 = a22 * (b21 - b11);\n            const m5 = (a11 + a12) * b22;\n            const m6 = (a21 - a11) * (b11 + b12);\n            const m7 = (a12 - a22) * (b21 + b22);\n\n            // Combine intermediate values into the output.\n            const c00 = m1 + m4 - m5 + m7;\n            const c01 = m3 + m5;\n            const c10 = m2 + m4;\n            const c11 = m1 - m2 + m3 + m6;\n\n            result.set(0, 0, c00);\n            result.set(0, 1, c01);\n            result.set(1, 0, c10);\n            result.set(1, 1, c11);\n            return result;\n        }\n\n        strassen3x3(other) {\n            var result = new this.constructor[Symbol.species](3, 3);\n\n            const a00 = this.get(0, 0);\n            const a01 = this.get(0, 1);\n            const a02 = this.get(0, 2);\n            const a10 = this.get(1, 0);\n            const a11 = this.get(1, 1);\n            const a12 = this.get(1, 2);\n            const a20 = this.get(2, 0);\n            const a21 = this.get(2, 1);\n            const a22 = this.get(2, 2);\n\n            const b00 = other.get(0, 0);\n            const b01 = other.get(0, 1);\n            const b02 = other.get(0, 2);\n            const b10 = other.get(1, 0);\n            const b11 = other.get(1, 1);\n            const b12 = other.get(1, 2);\n            const b20 = other.get(2, 0);\n            const b21 = other.get(2, 1);\n            const b22 = other.get(2, 2);\n\n            const m1 = (a00 + a01 + a02 - a10 - a11 - a21 - a22) * b11;\n            const m2 = (a00 - a10) * (-b01 + b11);\n            const m3 = a11 * (-b00 + b01 + b10 - b11 - b12 - b20 + b22);\n            const m4 = (-a00 + a10 + a11) * (b00 - b01 + b11);\n            const m5 = (a10 + a11) * (-b00 + b01);\n            const m6 = a00 * b00;\n            const m7 = (-a00 + a20 + a21) * (b00 - b02 + b12);\n            const m8 = (-a00 + a20) * (b02 - b12);\n            const m9 = (a20 + a21) * (-b00 + b02);\n            const m10 = (a00 + a01 + a02 - a11 - a12 - a20 - a21) * b12;\n            const m11 = a21 * (-b00 + b02 + b10 - b11 - b12 - b20 + b21);\n            const m12 = (-a02 + a21 + a22) * (b11 + b20 - b21);\n            const m13 = (a02 - a22) * (b11 - b21);\n            const m14 = a02 * b20;\n            const m15 = (a21 + a22) * (-b20 + b21);\n            const m16 = (-a02 + a11 + a12) * (b12 + b20 - b22);\n            const m17 = (a02 - a12) * (b12 - b22);\n            const m18 = (a11 + a12) * (-b20 + b22);\n            const m19 = a01 * b10;\n            const m20 = a12 * b21;\n            const m21 = a10 * b02;\n            const m22 = a20 * b01;\n            const m23 = a22 * b22;\n\n            const c00 = m6 + m14 + m19;\n            const c01 = m1 + m4 + m5 + m6 + m12 + m14 + m15;\n            const c02 = m6 + m7 + m9 + m10 + m14 + m16 + m18;\n            const c10 = m2 + m3 + m4 + m6 + m14 + m16 + m17;\n            const c11 = m2 + m4 + m5 + m6 + m20;\n            const c12 = m14 + m16 + m17 + m18 + m21;\n            const c20 = m6 + m7 + m8 + m11 + m12 + m13 + m14;\n            const c21 = m12 + m13 + m14 + m15 + m22;\n            const c22 = m6 + m7 + m8 + m9 + m23;\n\n            result.set(0, 0, c00);\n            result.set(0, 1, c01);\n            result.set(0, 2, c02);\n            result.set(1, 0, c10);\n            result.set(1, 1, c11);\n            result.set(1, 2, c12);\n            result.set(2, 0, c20);\n            result.set(2, 1, c21);\n            result.set(2, 2, c22);\n            return result;\n        }\n\n        /**\n         * Returns the matrix product between x and y. More efficient than mmul(other) only when we multiply squared matrix and when the size of the matrix is > 1000.\n         * @param {Matrix} y\n         * @return {Matrix}\n         */\n        mmulStrassen(y) {\n            var x = this.clone();\n            var r1 = x.rows;\n            var c1 = x.columns;\n            var r2 = y.rows;\n            var c2 = y.columns;\n            if (c1 !== r2) {\n                // eslint-disable-next-line no-console\n                console.warn(`Multiplying ${r1} x ${c1} and ${r2} x ${c2} matrix: dimensions do not match.`);\n            }\n\n            // Put a matrix into the top left of a matrix of zeros.\n            // `rows` and `cols` are the dimensions of the output matrix.\n            function embed(mat, rows, cols) {\n                var r = mat.rows;\n                var c = mat.columns;\n                if ((r === rows) && (c === cols)) {\n                    return mat;\n                } else {\n                    var resultat = Matrix.zeros(rows, cols);\n                    resultat = resultat.setSubMatrix(mat, 0, 0);\n                    return resultat;\n                }\n            }\n\n\n            // Make sure both matrices are the same size.\n            // This is exclusively for simplicity:\n            // this algorithm can be implemented with matrices of different sizes.\n\n            var r = Math.max(r1, r2);\n            var c = Math.max(c1, c2);\n            x = embed(x, r, c);\n            y = embed(y, r, c);\n\n            // Our recursive multiplication function.\n            function blockMult(a, b, rows, cols) {\n                // For small matrices, resort to naive multiplication.\n                if (rows <= 512 || cols <= 512) {\n                    return a.mmul(b); // a is equivalent to this\n                }\n\n                // Apply dynamic padding.\n                if ((rows % 2 === 1) && (cols % 2 === 1)) {\n                    a = embed(a, rows + 1, cols + 1);\n                    b = embed(b, rows + 1, cols + 1);\n                } else if (rows % 2 === 1) {\n                    a = embed(a, rows + 1, cols);\n                    b = embed(b, rows + 1, cols);\n                } else if (cols % 2 === 1) {\n                    a = embed(a, rows, cols + 1);\n                    b = embed(b, rows, cols + 1);\n                }\n\n                var halfRows = parseInt(a.rows / 2);\n                var halfCols = parseInt(a.columns / 2);\n                // Subdivide input matrices.\n                var a11 = a.subMatrix(0, halfRows - 1, 0, halfCols - 1);\n                var b11 = b.subMatrix(0, halfRows - 1, 0, halfCols - 1);\n\n                var a12 = a.subMatrix(0, halfRows - 1, halfCols, a.columns - 1);\n                var b12 = b.subMatrix(0, halfRows - 1, halfCols, b.columns - 1);\n\n                var a21 = a.subMatrix(halfRows, a.rows - 1, 0, halfCols - 1);\n                var b21 = b.subMatrix(halfRows, b.rows - 1, 0, halfCols - 1);\n\n                var a22 = a.subMatrix(halfRows, a.rows - 1, halfCols, a.columns - 1);\n                var b22 = b.subMatrix(halfRows, b.rows - 1, halfCols, b.columns - 1);\n\n                // Compute intermediate values.\n                var m1 = blockMult(Matrix.add(a11, a22), Matrix.add(b11, b22), halfRows, halfCols);\n                var m2 = blockMult(Matrix.add(a21, a22), b11, halfRows, halfCols);\n                var m3 = blockMult(a11, Matrix.sub(b12, b22), halfRows, halfCols);\n                var m4 = blockMult(a22, Matrix.sub(b21, b11), halfRows, halfCols);\n                var m5 = blockMult(Matrix.add(a11, a12), b22, halfRows, halfCols);\n                var m6 = blockMult(Matrix.sub(a21, a11), Matrix.add(b11, b12), halfRows, halfCols);\n                var m7 = blockMult(Matrix.sub(a12, a22), Matrix.add(b21, b22), halfRows, halfCols);\n\n                // Combine intermediate values into the output.\n                var c11 = Matrix.add(m1, m4);\n                c11.sub(m5);\n                c11.add(m7);\n                var c12 = Matrix.add(m3, m5);\n                var c21 = Matrix.add(m2, m4);\n                var c22 = Matrix.sub(m1, m2);\n                c22.add(m3);\n                c22.add(m6);\n\n                //Crop output to the desired size (undo dynamic padding).\n                var resultat = Matrix.zeros(2 * c11.rows, 2 * c11.columns);\n                resultat = resultat.setSubMatrix(c11, 0, 0);\n                resultat = resultat.setSubMatrix(c12, c11.rows, 0);\n                resultat = resultat.setSubMatrix(c21, 0, c11.columns);\n                resultat = resultat.setSubMatrix(c22, c11.rows, c11.columns);\n                return resultat.subMatrix(0, rows - 1, 0, cols - 1);\n            }\n            return blockMult(x, y, r, c);\n        }\n\n        /**\n         * Returns a row-by-row scaled matrix\n         * @param {number} [min=0] - Minimum scaled value\n         * @param {number} [max=1] - Maximum scaled value\n         * @return {Matrix} - The scaled matrix\n         */\n        scaleRows(min, max) {\n            min = min === undefined ? 0 : min;\n            max = max === undefined ? 1 : max;\n            if (min >= max) {\n                throw new RangeError('min should be strictly smaller than max');\n            }\n            var newMatrix = this.constructor.empty(this.rows, this.columns);\n            for (var i = 0; i < this.rows; i++) {\n                var scaled = arrayUtils.scale(this.getRow(i), {min, max});\n                newMatrix.setRow(i, scaled);\n            }\n            return newMatrix;\n        }\n\n        /**\n         * Returns a new column-by-column scaled matrix\n         * @param {number} [min=0] - Minimum scaled value\n         * @param {number} [max=1] - Maximum scaled value\n         * @return {Matrix} - The new scaled matrix\n         * @example\n         * var matrix = new Matrix([[1,2],[-1,0]]);\n         * var scaledMatrix = matrix.scaleColumns(); // [[1,1],[0,0]]\n         */\n        scaleColumns(min, max) {\n            min = min === undefined ? 0 : min;\n            max = max === undefined ? 1 : max;\n            if (min >= max) {\n                throw new RangeError('min should be strictly smaller than max');\n            }\n            var newMatrix = this.constructor.empty(this.rows, this.columns);\n            for (var i = 0; i < this.columns; i++) {\n                var scaled = arrayUtils.scale(this.getColumn(i), {\n                    min: min,\n                    max: max\n                });\n                newMatrix.setColumn(i, scaled);\n            }\n            return newMatrix;\n        }\n\n\n        /**\n         * Returns the Kronecker product (also known as tensor product) between this and other\n         * See https://en.wikipedia.org/wiki/Kronecker_product\n         * @param {Matrix} other\n         * @return {Matrix}\n         */\n        kroneckerProduct(other) {\n            other = this.constructor.checkMatrix(other);\n\n            var m = this.rows;\n            var n = this.columns;\n            var p = other.rows;\n            var q = other.columns;\n\n            var result = new this.constructor[Symbol.species](m * p, n * q);\n            for (var i = 0; i < m; i++) {\n                for (var j = 0; j < n; j++) {\n                    for (var k = 0; k < p; k++) {\n                        for (var l = 0; l < q; l++) {\n                            result[p * i + k][q * j + l] = this.get(i, j) * other.get(k, l);\n                        }\n                    }\n                }\n            }\n            return result;\n        }\n\n        /**\n         * Transposes the matrix and returns a new one containing the result\n         * @return {Matrix}\n         */\n        transpose() {\n            var result = new this.constructor[Symbol.species](this.columns, this.rows);\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    result.set(j, i, this.get(i, j));\n                }\n            }\n            return result;\n        }\n\n        /**\n         * Sorts the rows (in place)\n         * @param {function} compareFunction - usual Array.prototype.sort comparison function\n         * @return {Matrix} this\n         */\n        sortRows(compareFunction) {\n            if (compareFunction === undefined) compareFunction = compareNumbers;\n            for (var i = 0; i < this.rows; i++) {\n                this.setRow(i, this.getRow(i).sort(compareFunction));\n            }\n            return this;\n        }\n\n        /**\n         * Sorts the columns (in place)\n         * @param {function} compareFunction - usual Array.prototype.sort comparison function\n         * @return {Matrix} this\n         */\n        sortColumns(compareFunction) {\n            if (compareFunction === undefined) compareFunction = compareNumbers;\n            for (var i = 0; i < this.columns; i++) {\n                this.setColumn(i, this.getColumn(i).sort(compareFunction));\n            }\n            return this;\n        }\n\n        /**\n         * Returns a subset of the matrix\n         * @param {number} startRow - First row index\n         * @param {number} endRow - Last row index\n         * @param {number} startColumn - First column index\n         * @param {number} endColumn - Last column index\n         * @return {Matrix}\n         */\n        subMatrix(startRow, endRow, startColumn, endColumn) {\n            util.checkRange(this, startRow, endRow, startColumn, endColumn);\n            var newMatrix = new this.constructor[Symbol.species](endRow - startRow + 1, endColumn - startColumn + 1);\n            for (var i = startRow; i <= endRow; i++) {\n                for (var j = startColumn; j <= endColumn; j++) {\n                    newMatrix[i - startRow][j - startColumn] = this.get(i, j);\n                }\n            }\n            return newMatrix;\n        }\n\n        /**\n         * Returns a subset of the matrix based on an array of row indices\n         * @param {Array} indices - Array containing the row indices\n         * @param {number} [startColumn = 0] - First column index\n         * @param {number} [endColumn = this.columns-1] - Last column index\n         * @return {Matrix}\n         */\n        subMatrixRow(indices, startColumn, endColumn) {\n            if (startColumn === undefined) startColumn = 0;\n            if (endColumn === undefined) endColumn = this.columns - 1;\n            if ((startColumn > endColumn) || (startColumn < 0) || (startColumn >= this.columns) || (endColumn < 0) || (endColumn >= this.columns)) {\n                throw new RangeError('Argument out of range');\n            }\n\n            var newMatrix = new this.constructor[Symbol.species](indices.length, endColumn - startColumn + 1);\n            for (var i = 0; i < indices.length; i++) {\n                for (var j = startColumn; j <= endColumn; j++) {\n                    if (indices[i] < 0 || indices[i] >= this.rows) {\n                        throw new RangeError('Row index out of range: ' + indices[i]);\n                    }\n                    newMatrix.set(i, j - startColumn, this.get(indices[i], j));\n                }\n            }\n            return newMatrix;\n        }\n\n        /**\n         * Returns a subset of the matrix based on an array of column indices\n         * @param {Array} indices - Array containing the column indices\n         * @param {number} [startRow = 0] - First row index\n         * @param {number} [endRow = this.rows-1] - Last row index\n         * @return {Matrix}\n         */\n        subMatrixColumn(indices, startRow, endRow) {\n            if (startRow === undefined) startRow = 0;\n            if (endRow === undefined) endRow = this.rows - 1;\n            if ((startRow > endRow) || (startRow < 0) || (startRow >= this.rows) || (endRow < 0) || (endRow >= this.rows)) {\n                throw new RangeError('Argument out of range');\n            }\n\n            var newMatrix = new this.constructor[Symbol.species](endRow - startRow + 1, indices.length);\n            for (var i = 0; i < indices.length; i++) {\n                for (var j = startRow; j <= endRow; j++) {\n                    if (indices[i] < 0 || indices[i] >= this.columns) {\n                        throw new RangeError('Column index out of range: ' + indices[i]);\n                    }\n                    newMatrix.set(j - startRow, i, this.get(j, indices[i]));\n                }\n            }\n            return newMatrix;\n        }\n\n        /**\n         * Set a part of the matrix to the given sub-matrix\n         * @param {Matrix|Array< Array >} matrix - The source matrix from which to extract values.\n         * @param {number} startRow - The index of the first row to set\n         * @param {number} startColumn - The index of the first column to set\n         * @return {Matrix}\n         */\n        setSubMatrix(matrix, startRow, startColumn) {\n            matrix = this.constructor.checkMatrix(matrix);\n            var endRow = startRow + matrix.rows - 1;\n            var endColumn = startColumn + matrix.columns - 1;\n            util.checkRange(this, startRow, endRow, startColumn, endColumn);\n            for (var i = 0; i < matrix.rows; i++) {\n                for (var j = 0; j < matrix.columns; j++) {\n                    this[startRow + i][startColumn + j] = matrix.get(i, j);\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Return a new matrix based on a selection of rows and columns\n         * @param {Array<number>} rowIndices - The row indices to select. Order matters and an index can be more than once.\n         * @param {Array<number>} columnIndices - The column indices to select. Order matters and an index can be use more than once.\n         * @return {Matrix} The new matrix\n         */\n        selection(rowIndices, columnIndices) {\n            var indices = util.checkIndices(this, rowIndices, columnIndices);\n            var newMatrix = new this.constructor[Symbol.species](rowIndices.length, columnIndices.length);\n            for (var i = 0; i < indices.row.length; i++) {\n                var rowIndex = indices.row[i];\n                for (var j = 0; j < indices.column.length; j++) {\n                    var columnIndex = indices.column[j];\n                    newMatrix[i][j] = this.get(rowIndex, columnIndex);\n                }\n            }\n            return newMatrix;\n        }\n\n        /**\n         * Returns the trace of the matrix (sum of the diagonal elements)\n         * @return {number}\n         */\n        trace() {\n            var min = Math.min(this.rows, this.columns);\n            var trace = 0;\n            for (var i = 0; i < min; i++) {\n                trace += this.get(i, i);\n            }\n            return trace;\n        }\n\n        /*\n         Matrix views\n         */\n\n        /**\n         * Returns a view of the transposition of the matrix\n         * @return {MatrixTransposeView}\n         */\n        transposeView() {\n            return new MatrixTransposeView(this);\n        }\n\n        /**\n         * Returns a view of the row vector with the given index\n         * @param {number} row - row index of the vector\n         * @return {MatrixRowView}\n         */\n        rowView(row) {\n            util.checkRowIndex(this, row);\n            return new MatrixRowView(this, row);\n        }\n\n        /**\n         * Returns a view of the column vector with the given index\n         * @param {number} column - column index of the vector\n         * @return {MatrixColumnView}\n         */\n        columnView(column) {\n            util.checkColumnIndex(this, column);\n            return new MatrixColumnView(this, column);\n        }\n\n        /**\n         * Returns a view of the matrix flipped in the row axis\n         * @return {MatrixFlipRowView}\n         */\n        flipRowView() {\n            return new MatrixFlipRowView(this);\n        }\n\n        /**\n         * Returns a view of the matrix flipped in the column axis\n         * @return {MatrixFlipColumnView}\n         */\n        flipColumnView() {\n            return new MatrixFlipColumnView(this);\n        }\n\n        /**\n         * Returns a view of a submatrix giving the index boundaries\n         * @param {number} startRow - first row index of the submatrix\n         * @param {number} endRow - last row index of the submatrix\n         * @param {number} startColumn - first column index of the submatrix\n         * @param {number} endColumn - last column index of the submatrix\n         * @return {MatrixSubView}\n         */\n        subMatrixView(startRow, endRow, startColumn, endColumn) {\n            return new MatrixSubView(this, startRow, endRow, startColumn, endColumn);\n        }\n\n        /**\n         * Returns a view of the cross of the row indices and the column indices\n         * @example\n         * // resulting vector is [[2], [2]]\n         * var matrix = new Matrix([[1,2,3], [4,5,6]]).selectionView([0, 0], [1])\n         * @param {Array<number>} rowIndices\n         * @param {Array<number>} columnIndices\n         * @return {MatrixSelectionView}\n         */\n        selectionView(rowIndices, columnIndices) {\n            return new MatrixSelectionView(this, rowIndices, columnIndices);\n        }\n\n\n        /**\n        * Calculates and returns the determinant of a matrix as a Number\n        * @example\n        *   new Matrix([[1,2,3], [4,5,6]]).det()\n        * @return {number}\n        */\n        det() {\n            if (this.isSquare()) {\n                var a, b, c, d;\n                if (this.columns === 2) {\n                    // 2 x 2 matrix\n                    a = this.get(0, 0);\n                    b = this.get(0, 1);\n                    c = this.get(1, 0);\n                    d = this.get(1, 1);\n\n                    return a * d - (b * c);\n                } else if (this.columns === 3) {\n                    // 3 x 3 matrix\n                    var subMatrix0, subMatrix1, subMatrix2;\n                    subMatrix0 = this.selectionView([1, 2], [1, 2]);\n                    subMatrix1 = this.selectionView([1, 2], [0, 2]);\n                    subMatrix2 = this.selectionView([1, 2], [0, 1]);\n                    a = this.get(0, 0);\n                    b = this.get(0, 1);\n                    c = this.get(0, 2);\n\n                    return a * subMatrix0.det() - b * subMatrix1.det() + c * subMatrix2.det();\n                } else {\n                    // general purpose determinant using the LU decomposition\n                    return new LuDecomposition(this).determinant;\n                }\n\n            } else {\n                throw Error('Determinant can only be calculated for a square matrix.');\n            }\n        }\n\n        /**\n         * Returns inverse of a matrix if it exists or the pseudoinverse\n         * @param {number} threshold - threshold for taking inverse of singular values (default = 1e-15)\n         * @return {Matrix} the (pseudo)inverted matrix.\n         */\n        pseudoInverse(threshold) {\n            if (threshold === undefined) threshold = Number.EPSILON;\n            var svdSolution = new SvDecomposition(this, {autoTranspose: true});\n\n            var U = svdSolution.leftSingularVectors;\n            var V = svdSolution.rightSingularVectors;\n            var s = svdSolution.diagonal;\n\n            for (var i = 0; i < s.length; i++) {\n                if (Math.abs(s[i]) > threshold) {\n                    s[i] = 1.0 / s[i];\n                } else {\n                    s[i] = 0.0;\n                }\n            }\n\n            // convert list to diagonal\n            s = this.constructor[Symbol.species].diag(s);\n            return V.mmul(s.mmul(U.transposeView()));\n        }\n    }\n\n    Matrix.prototype.klass = 'Matrix';\n\n    /**\n     * @private\n     * Check that two matrices have the same dimensions\n     * @param {Matrix} matrix\n     * @param {Matrix} otherMatrix\n     */\n    function checkDimensions(matrix, otherMatrix) { // eslint-disable-line no-unused-vars\n        if (matrix.rows !== otherMatrix.rows ||\n            matrix.columns !== otherMatrix.columns) {\n            throw new RangeError('Matrices dimensions must be equal');\n        }\n    }\n\n    function compareNumbers(a, b) {\n        return a - b;\n    }\n\n    /*\n     Synonyms\n     */\n\n    Matrix.random = Matrix.rand;\n    Matrix.diagonal = Matrix.diag;\n    Matrix.prototype.diagonal = Matrix.prototype.diag;\n    Matrix.identity = Matrix.eye;\n    Matrix.prototype.negate = Matrix.prototype.neg;\n    Matrix.prototype.tensorProduct = Matrix.prototype.kroneckerProduct;\n    Matrix.prototype.determinant = Matrix.prototype.det;\n\n    /*\n     Add dynamically instance and static methods for mathematical operations\n     */\n\n    var inplaceOperator = `\n(function %name%(value) {\n    if (typeof value === 'number') return this.%name%S(value);\n    return this.%name%M(value);\n})\n`;\n\n    var inplaceOperatorScalar = `\n(function %name%S(value) {\n    for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n            this.set(i, j, this.get(i, j) %op% value);\n        }\n    }\n    return this;\n})\n`;\n\n    var inplaceOperatorMatrix = `\n(function %name%M(matrix) {\n    matrix = this.constructor.checkMatrix(matrix);\n    checkDimensions(this, matrix);\n    for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n            this.set(i, j, this.get(i, j) %op% matrix.get(i, j));\n        }\n    }\n    return this;\n})\n`;\n\n    var staticOperator = `\n(function %name%(matrix, value) {\n    var newMatrix = new this[Symbol.species](matrix);\n    return newMatrix.%name%(value);\n})\n`;\n\n    var inplaceMethod = `\n(function %name%() {\n    for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n            this.set(i, j, %method%(this.get(i, j)));\n        }\n    }\n    return this;\n})\n`;\n\n    var staticMethod = `\n(function %name%(matrix) {\n    var newMatrix = new this[Symbol.species](matrix);\n    return newMatrix.%name%();\n})\n`;\n\n    var inplaceMethodWithArgs = `\n(function %name%(%args%) {\n    for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n            this.set(i, j, %method%(this.get(i, j), %args%));\n        }\n    }\n    return this;\n})\n`;\n\n    var staticMethodWithArgs = `\n(function %name%(matrix, %args%) {\n    var newMatrix = new this[Symbol.species](matrix);\n    return newMatrix.%name%(%args%);\n})\n`;\n\n\n    var inplaceMethodWithOneArgScalar = `\n(function %name%S(value) {\n    for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n            this.set(i, j, %method%(this.get(i, j), value));\n        }\n    }\n    return this;\n})\n`;\n    var inplaceMethodWithOneArgMatrix = `\n(function %name%M(matrix) {\n    matrix = this.constructor.checkMatrix(matrix);\n    checkDimensions(this, matrix);\n    for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n            this.set(i, j, %method%(this.get(i, j), matrix.get(i, j)));\n        }\n    }\n    return this;\n})\n`;\n\n    var inplaceMethodWithOneArg = `\n(function %name%(value) {\n    if (typeof value === 'number') return this.%name%S(value);\n    return this.%name%M(value);\n})\n`;\n\n    var staticMethodWithOneArg = staticMethodWithArgs;\n\n    var operators = [\n        // Arithmetic operators\n        ['+', 'add'],\n        ['-', 'sub', 'subtract'],\n        ['*', 'mul', 'multiply'],\n        ['/', 'div', 'divide'],\n        ['%', 'mod', 'modulus'],\n        // Bitwise operators\n        ['&', 'and'],\n        ['|', 'or'],\n        ['^', 'xor'],\n        ['<<', 'leftShift'],\n        ['>>', 'signPropagatingRightShift'],\n        ['>>>', 'rightShift', 'zeroFillRightShift']\n    ];\n\n    var i;\n\n    for (var operator of operators) {\n        var inplaceOp = eval(fillTemplateFunction(inplaceOperator, {name: operator[1], op: operator[0]}));\n        var inplaceOpS = eval(fillTemplateFunction(inplaceOperatorScalar, {name: operator[1] + 'S', op: operator[0]}));\n        var inplaceOpM = eval(fillTemplateFunction(inplaceOperatorMatrix, {name: operator[1] + 'M', op: operator[0]}));\n        var staticOp = eval(fillTemplateFunction(staticOperator, {name: operator[1]}));\n        for (i = 1; i < operator.length; i++) {\n            Matrix.prototype[operator[i]] = inplaceOp;\n            Matrix.prototype[operator[i] + 'S'] = inplaceOpS;\n            Matrix.prototype[operator[i] + 'M'] = inplaceOpM;\n            Matrix[operator[i]] = staticOp;\n        }\n    }\n\n    var methods = [\n        ['~', 'not']\n    ];\n\n    [\n        'abs', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atanh', 'cbrt', 'ceil',\n        'clz32', 'cos', 'cosh', 'exp', 'expm1', 'floor', 'fround', 'log', 'log1p',\n        'log10', 'log2', 'round', 'sign', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc'\n    ].forEach(function (mathMethod) {\n        methods.push(['Math.' + mathMethod, mathMethod]);\n    });\n\n    for (var method of methods) {\n        var inplaceMeth = eval(fillTemplateFunction(inplaceMethod, {name: method[1], method: method[0]}));\n        var staticMeth = eval(fillTemplateFunction(staticMethod, {name: method[1]}));\n        for (i = 1; i < method.length; i++) {\n            Matrix.prototype[method[i]] = inplaceMeth;\n            Matrix[method[i]] = staticMeth;\n        }\n    }\n\n    var methodsWithArgs = [\n        ['Math.pow', 1, 'pow']\n    ];\n\n    for (var methodWithArg of methodsWithArgs) {\n        var args = 'arg0';\n        for (i = 1; i < methodWithArg[1]; i++) {\n            args += `, arg${i}`;\n        }\n        if (methodWithArg[1] !== 1) {\n            var inplaceMethWithArgs = eval(fillTemplateFunction(inplaceMethodWithArgs, {\n                name: methodWithArg[2],\n                method: methodWithArg[0],\n                args: args\n            }));\n            var staticMethWithArgs = eval(fillTemplateFunction(staticMethodWithArgs, {name: methodWithArg[2], args: args}));\n            for (i = 2; i < methodWithArg.length; i++) {\n                Matrix.prototype[methodWithArg[i]] = inplaceMethWithArgs;\n                Matrix[methodWithArg[i]] = staticMethWithArgs;\n            }\n        } else {\n            var tmplVar = {\n                name: methodWithArg[2],\n                args: args,\n                method: methodWithArg[0]\n            };\n            var inplaceMethod2 = eval(fillTemplateFunction(inplaceMethodWithOneArg, tmplVar));\n            var inplaceMethodS = eval(fillTemplateFunction(inplaceMethodWithOneArgScalar, tmplVar));\n            var inplaceMethodM = eval(fillTemplateFunction(inplaceMethodWithOneArgMatrix, tmplVar));\n            var staticMethod2 = eval(fillTemplateFunction(staticMethodWithOneArg, tmplVar));\n            for (i = 2; i < methodWithArg.length; i++) {\n                Matrix.prototype[methodWithArg[i]] = inplaceMethod2;\n                Matrix.prototype[methodWithArg[i] + 'M'] = inplaceMethodM;\n                Matrix.prototype[methodWithArg[i] + 'S'] = inplaceMethodS;\n                Matrix[methodWithArg[i]] = staticMethod2;\n            }\n        }\n    }\n\n    function fillTemplateFunction(template, values) {\n        for (var value in values) {\n            template = template.replace(new RegExp('%' + value + '%', 'g'), values[value]);\n        }\n        return template;\n    }\n\n    return Matrix;\n}\n","'use strict';\n\nvar BaseView = require('./base');\n\nclass MatrixRowView extends BaseView {\n    constructor(matrix, row) {\n        super(matrix, 1, matrix.columns);\n        this.row = row;\n    }\n\n    set(rowIndex, columnIndex, value) {\n        this.matrix.set(this.row, columnIndex, value);\n        return this;\n    }\n\n    get(rowIndex, columnIndex) {\n        return this.matrix.get(this.row, columnIndex);\n    }\n}\n\nmodule.exports = MatrixRowView;\n","'use strict';\n\nmodule.exports = require('./LM');\nmodule.exports.Matrix = require('ml-matrix');\nmodule.exports.Matrix.algebra = require('./algebra');\n","'use strict';\n\nvar BaseView = require('./base');\n\nclass MatrixColumnView extends BaseView {\n    constructor(matrix, column) {\n        super(matrix, matrix.rows, 1);\n        this.column = column;\n    }\n\n    set(rowIndex, columnIndex, value) {\n        this.matrix.set(rowIndex, this.column, value);\n        return this;\n    }\n\n    get(rowIndex) {\n        return this.matrix.get(rowIndex, this.column);\n    }\n}\n\nmodule.exports = MatrixColumnView;\n","'use strict';\n\nmodule.exports = require('./matrix').Matrix;\nmodule.exports.Decompositions = module.exports.DC = require('./decompositions');\n","'use strict';\n\nvar Matrix = require('../matrix').Matrix;\n\n// https://github.com/lutzroeder/Mapack/blob/master/Source/CholeskyDecomposition.cs\nfunction CholeskyDecomposition(value) {\n    if (!(this instanceof CholeskyDecomposition)) {\n        return new CholeskyDecomposition(value);\n    }\n    value = Matrix.checkMatrix(value);\n    if (!value.isSymmetric()) {\n        throw new Error('Matrix is not symmetric');\n    }\n\n    var a = value,\n        dimension = a.rows,\n        l = new Matrix(dimension, dimension),\n        positiveDefinite = true,\n        i, j, k;\n\n    for (j = 0; j < dimension; j++) {\n        var Lrowj = l[j];\n        var d = 0;\n        for (k = 0; k < j; k++) {\n            var Lrowk = l[k];\n            var s = 0;\n            for (i = 0; i < k; i++) {\n                s += Lrowk[i] * Lrowj[i];\n            }\n            Lrowj[k] = s = (a[j][k] - s) / l[k][k];\n            d = d + s * s;\n        }\n\n        d = a[j][j] - d;\n\n        positiveDefinite &= (d > 0);\n        l[j][j] = Math.sqrt(Math.max(d, 0));\n        for (k = j + 1; k < dimension; k++) {\n            l[j][k] = 0;\n        }\n    }\n\n    if (!positiveDefinite) {\n        throw new Error('Matrix is not positive definite');\n    }\n\n    this.L = l;\n}\n\nCholeskyDecomposition.prototype = {\n    get lowerTriangularMatrix() {\n        return this.L;\n    },\n    solve: function (value) {\n        value = Matrix.checkMatrix(value);\n\n        var l = this.L,\n            dimension = l.rows;\n\n        if (value.rows !== dimension) {\n            throw new Error('Matrix dimensions do not match');\n        }\n\n        var count = value.columns,\n            B = value.clone(),\n            i, j, k;\n\n        for (k = 0; k < dimension; k++) {\n            for (j = 0; j < count; j++) {\n                for (i = 0; i < k; i++) {\n                    B[k][j] -= B[i][j] * l[k][i];\n                }\n                B[k][j] /= l[k][k];\n            }\n        }\n\n        for (k = dimension - 1; k >= 0; k--) {\n            for (j = 0; j < count; j++) {\n                for (i = k + 1; i < dimension; i++) {\n                    B[k][j] -= B[i][j] * l[i][k];\n                }\n                B[k][j] /= l[k][k];\n            }\n        }\n\n        return B;\n    }\n};\n\nmodule.exports = CholeskyDecomposition;\n","'use strict';\n\nvar Matrix = require('../matrix').Matrix;\nvar hypotenuse = require('./util').hypotenuse;\n\n//https://github.com/lutzroeder/Mapack/blob/master/Source/QrDecomposition.cs\nfunction QrDecomposition(value) {\n    if (!(this instanceof QrDecomposition)) {\n        return new QrDecomposition(value);\n    }\n    value = Matrix.checkMatrix(value);\n\n    var qr = value.clone(),\n        m = value.rows,\n        n = value.columns,\n        rdiag = new Array(n),\n        i, j, k, s;\n\n    for (k = 0; k < n; k++) {\n        var nrm = 0;\n        for (i = k; i < m; i++) {\n            nrm = hypotenuse(nrm, qr[i][k]);\n        }\n        if (nrm !== 0) {\n            if (qr[k][k] < 0) {\n                nrm = -nrm;\n            }\n            for (i = k; i < m; i++) {\n                qr[i][k] /= nrm;\n            }\n            qr[k][k] += 1;\n            for (j = k + 1; j < n; j++) {\n                s = 0;\n                for (i = k; i < m; i++) {\n                    s += qr[i][k] * qr[i][j];\n                }\n                s = -s / qr[k][k];\n                for (i = k; i < m; i++) {\n                    qr[i][j] += s * qr[i][k];\n                }\n            }\n        }\n        rdiag[k] = -nrm;\n    }\n\n    this.QR = qr;\n    this.Rdiag = rdiag;\n}\n\nQrDecomposition.prototype = {\n    solve: function (value) {\n        value = Matrix.checkMatrix(value);\n\n        var qr = this.QR,\n            m = qr.rows;\n\n        if (value.rows !== m) {\n            throw new Error('Matrix row dimensions must agree');\n        }\n        if (!this.isFullRank()) {\n            throw new Error('Matrix is rank deficient');\n        }\n\n        var count = value.columns;\n        var X = value.clone();\n        var n = qr.columns;\n        var i, j, k, s;\n\n        for (k = 0; k < n; k++) {\n            for (j = 0; j < count; j++) {\n                s = 0;\n                for (i = k; i < m; i++) {\n                    s += qr[i][k] * X[i][j];\n                }\n                s = -s / qr[k][k];\n                for (i = k; i < m; i++) {\n                    X[i][j] += s * qr[i][k];\n                }\n            }\n        }\n        for (k = n - 1; k >= 0; k--) {\n            for (j = 0; j < count; j++) {\n                X[k][j] /= this.Rdiag[k];\n            }\n            for (i = 0; i < k; i++) {\n                for (j = 0; j < count; j++) {\n                    X[i][j] -= X[k][j] * qr[i][k];\n                }\n            }\n        }\n\n        return X.subMatrix(0, n - 1, 0, count - 1);\n    },\n    isFullRank: function () {\n        var columns = this.QR.columns;\n        for (var i = 0; i < columns; i++) {\n            if (this.Rdiag[i] === 0) {\n                return false;\n            }\n        }\n        return true;\n    },\n    get upperTriangularMatrix() {\n        var qr = this.QR,\n            n = qr.columns,\n            X = new Matrix(n, n),\n            i, j;\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < n; j++) {\n                if (i < j) {\n                    X[i][j] = qr[i][j];\n                } else if (i === j) {\n                    X[i][j] = this.Rdiag[i];\n                } else {\n                    X[i][j] = 0;\n                }\n            }\n        }\n        return X;\n    },\n    get orthogonalMatrix() {\n        var qr = this.QR,\n            rows = qr.rows,\n            columns = qr.columns,\n            X = new Matrix(rows, columns),\n            i, j, k, s;\n\n        for (k = columns - 1; k >= 0; k--) {\n            for (i = 0; i < rows; i++) {\n                X[i][k] = 0;\n            }\n            X[k][k] = 1;\n            for (j = k; j < columns; j++) {\n                if (qr[k][k] !== 0) {\n                    s = 0;\n                    for (i = k; i < rows; i++) {\n                        s += qr[i][k] * X[i][j];\n                    }\n\n                    s = -s / qr[k][k];\n\n                    for (i = k; i < rows; i++) {\n                        X[i][j] += s * qr[i][k];\n                    }\n                }\n            }\n        }\n        return X;\n    }\n};\n\nmodule.exports = QrDecomposition;\n","/**\n * Created by acastillo on 8/5/15.\n */\nvar Matrix = require(\"ml-matrix\");\nvar math = require(\"./algebra\");\n\nvar DEBUG = false;\n/** Levenberg Marquardt curve-fitting: minimize sum of weighted squared residuals\n ----------  INPUT  VARIABLES  -----------\n func   = function of n independent variables, 't', and m parameters, 'p',\n returning the simulated model: y_hat = func(t,p,c)\n p      = n-vector of initial guess of parameter values\n t      = m-vectors or matrix of independent variables (used as arg to func)\n y_dat  = m-vectors or matrix of data to be fit by func(t,p)\n weight = weighting vector for least squares fit ( weight >= 0 ) ...\n inverse of the standard measurement errors\n Default:  sqrt(d.o.f. / ( y_dat' * y_dat ))\n dp     = fractional increment of 'p' for numerical derivatives\n dp(j)>0 central differences calculated\n dp(j)<0 one sided 'backwards' differences calculated\n dp(j)=0 sets corresponding partials to zero; i.e. holds p(j) fixed\n Default:  0.001;\n p_min  = n-vector of lower bounds for parameter values\n p_max  = n-vector of upper bounds for parameter values\n c      = an optional matrix of values passed to func(t,p,c)\n opts   = vector of algorithmic parameters\n parameter    defaults    meaning\n opts(1)  =  prnt            3        >1 intermediate results; >2 plots\n opts(2)  =  MaxIter      10*Npar     maximum number of iterations\n opts(3)  =  epsilon_1       1e-3     convergence tolerance for gradient\n opts(4)  =  epsilon_2       1e-3     convergence tolerance for parameters\n opts(5)  =  epsilon_3       1e-3     convergence tolerance for Chi-square\n opts(6)  =  epsilon_4       1e-2     determines acceptance of a L-M step\n opts(7)  =  lambda_0        1e-2     initial value of L-M paramter\n opts(8)  =  lambda_UP_fac   11       factor for increasing lambda\n opts(9)  =  lambda_DN_fac    9       factor for decreasing lambda\n opts(10) =  Update_Type      1       1: Levenberg-Marquardt lambda update\n 2: Quadratic update\n 3: Nielsen's lambda update equations\n\n ----------  OUTPUT  VARIABLES  -----------\n p       = least-squares optimal estimate of the parameter values\n X2      = Chi squared criteria\n sigma_p = asymptotic standard error of the parameters\n sigma_y = asymptotic standard error of the curve-fit\n corr    = correlation matrix of the parameters\n R_sq    = R-squared cofficient of multiple determination\n cvg_hst = convergence history\n\n Henri Gavin, Dept. Civil & Environ. Engineering, Duke Univ. 22 Sep 2013\n modified from: http://octave.sourceforge.net/optim/function/leasqr.html\n using references by\n Press, et al., Numerical Recipes, Cambridge Univ. Press, 1992, Chapter 15.\n Sam Roweis       http://www.cs.toronto.edu/~roweis/notes/lm.pdf\n Manolis Lourakis http://www.ics.forth.gr/~lourakis/levmar/levmar.pdf\n Hans Nielson     http://www2.imm.dtu.dk/~hbn/publ/TR9905.ps\n Mathworks        optimization toolbox reference manual\n K. Madsen, H.B., Nielsen, and O. Tingleff\n http://www2.imm.dtu.dk/pubdb/views/edoc_download.php/3215/pdf/imm3215.pdf\n */\nvar LM = {\n\n    optimize: function(func,p,t,y_dat,weight,dp,p_min,p_max,c,opts){\n\n        var tensor_parameter = 0;\t\t\t// set to 1 of parameter is a tensor\n\n        var iteration  = 0;\t\t\t// iteration counter\n        //func_calls = 0;\t\t\t// running count of function evaluations\n\n        if((typeof p[0])!=\"object\"){\n            for(var i=0;i< p.length;i++){\n                p[i]=[p[i]];\n            }\n\n        }\n        //p = p(:); y_dat = y_dat(:); \t\t// make column vectors\n        var i,k;\n        var eps = 2^-52;\n        var Npar   = p.length;//length(p); \t\t\t// number of parameters\n        var Npnt   = y_dat.length;//length(y_dat);\t\t// number of data points\n        var p_old  = Matrix.zeros(Npar,1);\t\t// previous set of parameters\n        var y_old  = Matrix.zeros(Npnt,1);\t\t// previous model, y_old = y_hat(t;p_old)\n        var X2     = 1e-2/eps;\t\t\t// a really big initial Chi-sq value\n        var X2_old = 1e-2/eps;\t\t\t// a really big initial Chi-sq value\n        var J =  Matrix.zeros(Npnt,Npar);\n\n\n        if (t.length != y_dat.length) {\n            console.log('lm.m error: the length of t must equal the length of y_dat');\n\n            length_t = t.length;\n            length_y_dat = y_dat.length;\n            var X2 = 0, corr = 0, sigma_p = 0, sigma_y = 0, R_sq = 0, cvg_hist = 0;\n            if (!tensor_parameter) {\n                return;\n            }\n        }\n\n        weight = weight||Math.sqrt((Npnt-Npar+1)/(math.multiply(math.transpose(y_dat),y_dat)));\n        dp = dp || 0.001;\n        p_min   = p_min || math.multiply(Math.abs(p),-100);\n        p_max   = p_max || math.multiply(Math.abs(p),100);\n        c = c || 1;\n        // Algorithmic Paramters\n        //prnt MaxIter  eps1  eps2  epx3  eps4  lam0  lamUP lamDN UpdateType\n        opts = opts ||[  3,10*Npar, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2, 11, 9, 1 ];\n\n        var prnt          = opts[0];\t// >1 intermediate results; >2 plots\n        var MaxIter       = opts[1];\t// maximum number of iterations\n        var epsilon_1     = opts[2];\t// convergence tolerance for gradient\n        var epsilon_2     = opts[3];\t// convergence tolerance for parameter\n        var epsilon_3     = opts[4];\t// convergence tolerance for Chi-square\n        var epsilon_4     = opts[5];\t// determines acceptance of a L-M step\n        var lambda_0      = opts[6];\t// initial value of damping paramter, lambda\n        var lambda_UP_fac = opts[7];\t// factor for increasing lambda\n        var lambda_DN_fac = opts[8];\t// factor for decreasing lambda\n        var Update_Type   = opts[9];\t// 1: Levenberg-Marquardt lambda update\n        // 2: Quadratic update\n        // 3: Nielsen's lambda update equations\n\n        if ( tensor_parameter && prnt == 3 ) prnt = 2;\n\n\n        if(!dp.length || dp.length == 1){\n            var dp_array = new Array(Npar);\n            for(var i=0;i<Npar;i++)\n                dp_array[i]=[dp];\n            dp=dp_array;\n        }\n\n        // indices of the parameters to be fit\n        var idx   = [];\n        for(i=0;i<dp.length;i++){\n            if(dp[i][0]!=0){\n                idx.push(i);\n            }\n        }\n\n        var Nfit = idx.length;\t\t\t// number of parameters to fit\n        var stop = false;\t\t\t\t// termination flag\n\n        var weight_sq = null;\n        //console.log(weight);\n        if ( !weight.length || weight.length < Npnt )\t{\n            // squared weighting vector\n            //weight_sq = ( weight(1)*ones(Npnt,1) ).^2;\n            //console.log(\"weight[0] \"+typeof weight[0]);\n            var tmp = math.multiply(Matrix.ones(Npnt,1),weight[0]);\n            weight_sq = math.dotMultiply(tmp,tmp);\n        }\n        else{\n            //weight_sq = (weight(:)).^2;\n            weight_sq = math.dotMultiply(weight,weight);\n        }\n\n\n        // initialize Jacobian with finite difference calculation\n        //console.log(\"J \"+weight_sq);\n        var result = this.lm_matx(func,t,p_old,y_old,1,J,p,y_dat,weight_sq,dp,c);\n        var JtWJ = result.JtWJ,JtWdy=result.JtWdy,X2=result.Chi_sq,y_hat=result.y_hat,J=result.J;\n        //[JtWJ,JtWdy,X2,y_hat,J] = this.lm_matx(func,t,p_old,y_old,1,J,p,y_dat,weight_sq,dp,c);\n        //console.log(JtWJ);\n\n        if ( Math.max(Math.abs(JtWdy)) < epsilon_1 ){\n            console.log(' *** Your Initial Guess is Extremely Close to Optimal ***')\n            console.log(' *** epsilon_1 = ', epsilon_1);\n            stop = true;\n        }\n\n\n        switch(Update_Type){\n            case 1: // Marquardt: init'l lambda\n                lambda  = lambda_0;\n                break;\n            default:    // Quadratic and Nielsen\n                lambda  = lambda_0 * Math.max(math.diag(JtWJ));\n                nu=2;\n        }\n        //console.log(X2);\n        X2_old = X2; // previous value of X2\n        //console.log(MaxIter+\" \"+Npar);\n        //var cvg_hst = Matrix.ones(MaxIter,Npar+3);\t\t// initialize convergence history\n        var h = null;\n        while ( !stop && iteration <= MaxIter ) {\t\t// --- Main Loop\n            iteration = iteration + 1;\n            // incremental change in parameters\n            switch(Update_Type){\n                case 1:\t\t\t\t\t// Marquardt\n                    //h = ( JtWJ + lambda * math.diag(math.diag(JtWJ)) ) \\ JtWdy;\n                    //h = math.multiply(math.inv(JtWdy),math.add(JtWJ,math.multiply(lambda,math.diag(math.diag(Npar)))));\n                    h = math.solve(math.add(JtWJ,math.multiply(math.diag(math.diag(JtWJ)),lambda)),JtWdy);\n                    break;\n                default:\t\t\t\t\t// Quadratic and Nielsen\n                    //h = ( JtWJ + lambda * math.eye(Npar) ) \\ JtWdy;\n\n                    h = math.solve(math.add(JtWJ,math.multiply( Matrix.eye(Npar),lambda)),JtWdy);\n            }\n\n            /*for(var k=0;k< h.length;k++){\n             h[k]=[h[k]];\n             }*/\n            //console.log(\"h \"+h);\n            //h=math.matrix(h);\n            //  big = max(abs(h./p)) > 2;\n            //this is a big step\n            // --- Are parameters [p+h] much better than [p] ?\n            var hidx = new Array(idx.length);\n            for(k=0;k<idx.length;k++){\n                hidx[k]=h[idx[k]];\n            }\n            var p_try = math.add(p, hidx);// update the [idx] elements\n\n            for(k=0;k<p_try.length;k++){\n                p_try[k][0]=Math.min(Math.max(p_min[k][0],p_try[k][0]),p_max[k][0]);\n            }\n            // p_try = Math.min(Math.max(p_min,p_try),p_max);           // apply constraints\n\n            var delta_y = math.subtract(y_dat, func(t,p_try,c));       // residual error using p_try\n            //func_calls = func_calls + 1;\n            //X2_try = delta_y' * ( delta_y .* weight_sq );  // Chi-squared error criteria\n\n            var X2_try = math.multiply(math.transpose(delta_y),math.dotMultiply(delta_y,weight_sq));\n\n            if ( Update_Type == 2 ){  \t\t\t  // Quadratic\n                //    One step of quadratic line update in the h direction for minimum X2\n                //var alpha =  JtWdy'*h / ( (X2_try - X2)/2 + 2*JtWdy'*h ) ;\n                var JtWdy_th = math.multiply(math.transpose(JtWdy),h);\n                var alpha =  math.multiply(JtWdy_th,math.inv(math.add(math.multiply(math.subtract(X2_try - X2),1/2)),math.multiply(JtWdy_th,2)));//JtWdy'*h / ( (X2_try - X2)/2 + 2*JtWdy'*h ) ;\n\n                h = math.multiply(alpha, h);\n                for(var k=0;k<idx.length;k++){\n                    hidx[k]=h[idx[k]];\n                }\n\n                p_try = math.add(p ,hidx);                     // update only [idx] elements\n                p_try = math.min(math.max(p_min,p_try),p_max);          // apply constraints\n\n                delta_y = math.subtract(y_dat, func(t,p_try,c));      // residual error using p_try\n                // func_calls = func_calls + 1;\n                //X2_try = delta_y' * ( delta_y .* weight_sq ); // Chi-squared error criteria\n                X2_try = math.multiply(math.transpose(delta_y), mat.dotMultiply(delta_y, weight_sq));\n            }\n\n            //rho = (X2 - X2_try) / ( 2*h' * (lambda * h + JtWdy) ); // Nielsen\n            var rho = (X2-X2_try)/math.multiply(math.multiply(math.transpose(h),2),math.add(math.multiply(lambda, h),JtWdy));\n            //console.log(\"rho \"+rho);\n            if ( rho > epsilon_4 ) {\t\t// it IS significantly better\n                //console.log(\"Here\");\n                dX2 = X2 - X2_old;\n                X2_old = X2;\n                p_old = p;\n                y_old = y_hat;\n                p = p_try;\t\t\t// accept p_try\n\n                result = this.lm_matx(func, t, p_old, y_old, dX2, J, p, y_dat, weight_sq, dp, c);\n                JtWJ = result.JtWJ,JtWdy=result.JtWdy,X2=result.Chi_sq,y_hat=result.y_hat,J=result.J;\n                // decrease lambda ==> Gauss-Newton method\n\n                switch (Update_Type) {\n                    case 1:\t\t\t\t\t\t\t// Levenberg\n                        lambda = Math.max(lambda / lambda_DN_fac, 1.e-7);\n                        break;\n                    case 2:\t\t\t\t\t\t\t// Quadratic\n                        lambda = Math.max(lambda / (1 + alpha), 1.e-7);\n                        break;\n                    case 3:\t\t\t\t\t\t\t// Nielsen\n                        lambda = math.multiply(Math.max(1 / 3, 1 - (2 * rho - 1) ^ 3),lambda);\n                        nu = 2;\n                        break;\n                }\n            }\n            else {\t\t\t\t\t// it IS NOT better\n                X2 = X2_old;\t\t\t// do not accept p_try\n                if (iteration%(2 * Npar)==0) {\t// rank-1 update of Jacobian\n                    result = this.lm_matx(func, t, p_old, y_old, -1, J, p, y_dat, weight_sq, dp, c);\n                    JtWJ = result.JtWJ,JtWdy=result.JtWdy,dX2=result.Chi_sq,y_hat=result.y_hat,J=result.J;\n                }\n\n                // increase lambda  ==> gradient descent method\n                switch (Update_Type) {\n                    case 1:\t\t\t\t\t\t\t// Levenberg\n                        lambda = Math.min(lambda * lambda_UP_fac, 1.e7);\n                        break;\n                    case 2:\t\t\t\t\t\t\t// Quadratic\n                        lambda = lambda + Math.abs((X2_try - X2) / 2 / alpha);\n                        break;\n                    case 3:\t\t\t\t\t\t// Nielsen\n                        lambda = lambda * nu;\n                        nu = 2 * nu;\n                        break;\n                }\n            }\n        }// --- End of Main Loop\n\n        // --- convergence achieved, find covariance and confidence intervals\n\n        // equal weights for paramter error analysis\n        weight_sq = math.multiply(math.multiply(math.transpose(delta_y),delta_y), Matrix.ones(Npnt,1));\n\n        weight_sq.apply(function(i,j){\n            weight_sq[i][j] = (Npnt-Nfit+1)/weight_sq[i][j];\n        });\n        //console.log(weight_sq);\n        result = this.lm_matx(func,t,p_old,y_old,-1,J,p,y_dat,weight_sq,dp,c);\n        JtWJ = result.JtWJ,JtWdy=result.JtWdy,X2=result.Chi_sq,y_hat=result.y_hat,J=result.J;\n\n        /*if nargout > 2\t\t\t\t// standard error of parameters\n         covar = inv(JtWJ);\n         sigma_p = sqrt(diag(covar));\n         end\n\n         if nargout > 3\t\t\t\t// standard error of the fit\n         //  sigma_y = sqrt(diag(J * covar * J'));\t// slower version of below\n         sigma_y = zeros(Npnt,1);\n         for i=1:Npnt\n         sigma_y(i) = J(i,:) * covar * J(i,:)';\n         end\n         sigma_y = sqrt(sigma_y);\n         end\n\n         if nargout > 4\t\t\t\t// parameter correlation matrix\n         corr = covar ./ [sigma_p*sigma_p'];\n         end\n\n         if nargout > 5\t\t\t\t// coefficient of multiple determination\n         R_sq = corrcoef([y_dat y_hat]);\n         R_sq = R_sq(1,2).^2;\n         end\n\n         if nargout > 6\t\t\t\t// convergence history\n         cvg_hst = cvg_hst(1:iteration,:);\n         end*/\n\n        // endfunction  # ---------------------------------------------------------- LM\n\n        return { p:p, X2:X2};\n    },\n\n    lm_FD_J:function(func,t,p,y,dp,c) {\n        // J = lm_FD_J(func,t,p,y,{dp},{c})\n        //\n        // partial derivatives (Jacobian) dy/dp for use with lm.m\n        // computed via Finite Differences\n        // Requires n or 2n function evaluations, n = number of nonzero values of dp\n        // -------- INPUT VARIABLES ---------\n        // func = function of independent variables, 't', and parameters, 'p',\n        //        returning the simulated model: y_hat = func(t,p,c)\n        // t  = m-vector of independent variables (used as arg to func)\n        // p  = n-vector of current parameter values\n        // y  = func(t,p,c) n-vector initialised by user before each call to lm_FD_J\n        // dp = fractional increment of p for numerical derivatives\n        //      dp(j)>0 central differences calculated\n        //      dp(j)<0 one sided differences calculated\n        //      dp(j)=0 sets corresponding partials to zero; i.e. holds p(j) fixed\n        //      Default:  0.001;\n        // c  = optional vector of constants passed to y_hat = func(t,p,c)\n        //---------- OUTPUT VARIABLES -------\n        // J  = Jacobian Matrix J(i,j)=dy(i)/dp(j)\ti=1:n; j=1:m\n\n        //   Henri Gavin, Dept. Civil & Environ. Engineering, Duke Univ. November 2005\n        //   modified from: ftp://fly.cnuce.cnr.it/pub/software/octave/leasqr/\n        //   Press, et al., Numerical Recipes, Cambridge Univ. Press, 1992, Chapter 15.\n\n        var m = y.length;\t\t\t// number of data points\n        var n = p.length;\t\t\t// number of parameters\n\n        dp = dp || math.multiply( Matrix.ones(n, 1), 0.001);\n\n        var ps = p.clone();//JSON.parse(JSON.stringify(p));\n        //var ps = $.extend(true, [], p);\n        var J = new Matrix(m,n), del =new Array(n);         // initialize Jacobian to Zero\n\n        for (var j = 0;j < n; j++) {\n            //console.log(j+\" \"+dp[j]+\" \"+p[j]+\" \"+ps[j]+\" \"+del[j]);\n            del[j] = dp[j]*(1+Math.abs(p[j][0]));  // parameter perturbation\n            p[j] = [ps[j][0]+del[j]];\t      // perturb parameter p(j)\n            //console.log(j+\" \"+dp[j]+\" \"+p[j]+\" \"+ps[j]+\" \"+del[j]);\n\n            if (del[j] != 0){\n                y1 = func(t, p, c);\n                //func_calls = func_calls + 1;\n                if (dp[j][0] < 0) {\t\t// backwards difference\n                    //J(:,j) = math.dotDivide(math.subtract(y1, y),del[j]);//. / del[j];\n                    //console.log(del[j]);\n                    //console.log(y);\n                    var column = math.dotDivide(math.subtract(y1, y),del[j]);\n                    for(var k=0;k< m;k++){\n                        J[k][j]=column[k][0];\n                    }\n                    //console.log(column);\n                }\n                else{\n                    p[j][0] = ps[j][0] - del[j];\n                    //J(:,j) = (y1 - feval(func, t, p, c)). / (2. * del[j]);\n                    var column = math.dotDivide(math.subtract(y1,func(t,p,c)),2*del[j]);\n                    for(var k=0;k< m;k++){\n                        J[k][j]=column[k][0];\n                    }\n\n                }\t\t\t// central difference, additional func call\n            }\n\n            p[j] = ps[j];\t\t// restore p(j)\n\n        }\n        //console.log(\"lm_FD_J: \"+ JSON.stringify(J));\n        return J;\n\n    },\n\n    // endfunction # -------------------------------------------------- LM_FD_J\n    lm_Broyden_J: function(p_old,y_old,J,p,y){\n        // J = lm_Broyden_J(p_old,y_old,J,p,y)\n        // carry out a rank-1 update to the Jacobian matrix using Broyden's equation\n        //---------- INPUT VARIABLES -------\n        // p_old = previous set of parameters\n        // y_old = model evaluation at previous set of parameters, y_hat(t;p_old)\n        // J  = current version of the Jacobian matrix\n        // p     = current  set of parameters\n        // y     = model evaluation at current  set of parameters, y_hat(t;p)\n        //---------- OUTPUT VARIABLES -------\n        // J = rank-1 update to Jacobian Matrix J(i,j)=dy(i)/dp(j)\ti=1:n; j=1:m\n        //console.log(p+\" X \"+ p_old)\n        var h  = math.subtract(p, p_old);\n\n        //console.log(\"hhh \"+h);\n        var h_t = math.transpose(h);\n        h_t.div(math.multiply(h_t,h));\n\n        //console.log(h_t);\n        //J = J + ( y - y_old - J*h )*h' / (h'*h);\t// Broyden rank-1 update eq'n\n        J = math.add(J, math.multiply(math.subtract(y, math.add(y_old,math.multiply(J,h))),h_t));\n        return J;\n        // endfunction # ---------------------------------------------- LM_Broyden_J\n    },\n\n    lm_matx : function (func,t,p_old,y_old,dX2,J,p,y_dat,weight_sq,dp,c,iteration){\n        // [JtWJ,JtWdy,Chi_sq,y_hat,J] = this.lm_matx(func,t,p_old,y_old,dX2,J,p,y_dat,weight_sq,{da},{c})\n        //\n        // Evaluate the linearized fitting matrix, JtWJ, and vector JtWdy,\n        // and calculate the Chi-squared error function, Chi_sq\n        // Used by Levenberg-Marquard algorithm, lm.m\n        // -------- INPUT VARIABLES ---------\n        // func   = function ofpn independent variables, p, and m parameters, p,\n        //         returning the simulated model: y_hat = func(t,p,c)\n        // t      = m-vectors or matrix of independent variables (used as arg to func)\n        // p_old  = n-vector of previous parameter values\n        // y_old  = m-vector of previous model ... y_old = y_hat(t;p_old);\n        // dX2    = previous change in Chi-squared criteria\n        // J   = m-by-n Jacobian of model, y_hat, with respect to parameters, p\n        // p      = n-vector of current  parameter values\n        // y_dat  = n-vector of data to be fit by func(t,p,c)\n        // weight_sq = square of the weighting vector for least squares fit ...\n        //\t    inverse of the standard measurement errors\n        // dp     = fractional increment of 'p' for numerical derivatives\n        //          dp(j)>0 central differences calculated\n        //          dp(j)<0 one sided differences calculated\n        //          dp(j)=0 sets corresponding partials to zero; i.e. holds p(j) fixed\n        //          Default:  0.001;\n        // c      = optional vector of constants passed to y_hat = func(t,p,c)\n        //---------- OUTPUT VARIABLES -------\n        // JtWJ\t = linearized Hessian matrix (inverse of covariance matrix)\n        // JtWdy   = linearized fitting vector\n        // Chi_sq = Chi-squared criteria: weighted sum of the squared residuals WSSR\n        // y_hat  = model evaluated with parameters 'p'\n        // J   = m-by-n Jacobian of model, y_hat, with respect to parameters, p\n\n        //   Henri Gavin, Dept. Civil & Environ. Engineering, Duke Univ. November 2005\n        //   modified from: ftp://fly.cnuce.cnr.it/pub/software/octave/leasqr/\n        //   Press, et al., Numerical Recipes, Cambridge Univ. Press, 1992, Chapter 15.\n\n\n        var Npnt = y_dat.length;\t\t// number of data points\n        var Npar = p.length;\t\t// number of parameters\n\n        dp = dp || 0.001;\n\n\n        //var JtWJ = new Matrix.zeros(Npar);\n        //var JtWdy  = new Matrix.zeros(Npar,1);\n\n        var y_hat = func(t,p,c);\t// evaluate model using parameters 'p'\n        //func_calls = func_calls + 1;\n        //console.log(J);\n        if ( (iteration%(2*Npar))==0 || dX2 > 0 ) {\n            //console.log(\"Par\");\n            J = this.lm_FD_J(func, t, p, y_hat, dp, c);\t\t// finite difference\n        }\n        else{\n            //console.log(\"ImPar\");\n            J = this.lm_Broyden_J(p_old, y_old, J, p, y_hat); // rank-1 update\n        }\n        //console.log(y_dat);\n        //console.log(y_hat);\n        var delta_y = math.subtract(y_dat, y_hat);\t// residual error between model and data\n        //console.log(delta_y[0][0]);\n        //console.log(delta_y.rows+\" \"+delta_y.columns+\" \"+JSON.stringify(weight_sq));\n        //var Chi_sq = delta_y' * ( delta_y .* weight_sq ); \t// Chi-squared error criteria\n        var Chi_sq = math.multiply(math.transpose(delta_y),math.dotMultiply(delta_y,weight_sq));\n        //JtWJ  = J' * ( J .* ( weight_sq * ones(1,Npar) ) );\n        var Jt = math.transpose(J);\n\n        //console.log(weight_sq);\n\n        var JtWJ = math.multiply(Jt, math.dotMultiply(J,math.multiply(weight_sq, Matrix.ones(1,Npar))));\n\n        //JtWdy = J' * ( weight_sq .* delta_y );\n        var JtWdy = math.multiply(Jt, math.dotMultiply(weight_sq,delta_y));\n\n\n        return {JtWJ:JtWJ,JtWdy:JtWdy,Chi_sq:Chi_sq,y_hat:y_hat,J:J};\n        // endfunction  # ------------------------------------------------------ LM_MATX\n    }\n\n\n\n};\n\nmodule.exports = LM;","module.exports = exports = require('./ArrayUtils');\n\n\nexports.getEquallySpacedData = require('./getEquallySpaced').getEquallySpacedData;\nexports.SNV = require('./snv').SNV;\n","'use strict';\n\n/**\n *\n * Function that returns a Number array of equally spaced numberOfPoints\n * containing a representation of intensities of the spectra arguments x\n * and y.\n *\n * The options parameter contains an object in the following form:\n * from: starting point\n * to: last point\n * numberOfPoints: number of points between from and to\n * variant: \"slot\" or \"smooth\" - smooth is the default option\n *\n * The slot variant consist that each point in the new array is calculated\n * averaging the existing points between the slot that belongs to the current\n * value. The smooth variant is the same but takes the integral of the range\n * of the slot and divide by the step size between two points in the new array.\n *\n * @param x - sorted increasing x values\n * @param y\n * @param options\n * @returns {Array} new array with the equally spaced data.\n *\n */\nfunction getEquallySpacedData(x, y, options) {\n    if (x.length>1 && x[0]>x[1]) {\n        x=x.slice().reverse();\n        y=y.slice().reverse();\n    }\n\n    var xLength = x.length;\n    if(xLength !== y.length)\n        throw new RangeError(\"the x and y vector doesn't have the same size.\");\n\n    if (options === undefined) options = {};\n\n    var from = options.from === undefined ? x[0] : options.from\n    if (isNaN(from) || !isFinite(from)) {\n        throw new RangeError(\"'From' value must be a number\");\n    }\n    var to = options.to === undefined ? x[x.length - 1] : options.to;\n    if (isNaN(to) || !isFinite(to)) {\n        throw new RangeError(\"'To' value must be a number\");\n    }\n\n    var reverse = from > to;\n    if(reverse) {\n        var temp = from;\n        from = to;\n        to = temp;\n    }\n\n    var numberOfPoints = options.numberOfPoints === undefined ? 100 : options.numberOfPoints;\n    if (isNaN(numberOfPoints) || !isFinite(numberOfPoints)) {\n        throw new RangeError(\"'Number of points' value must be a number\");\n    }\n    if(numberOfPoints < 1)\n        throw new RangeError(\"the number of point must be higher than 1\");\n\n    var algorithm = options.variant === \"slot\" ? \"slot\" : \"smooth\"; // default value: smooth\n\n    var output = algorithm === \"slot\" ? getEquallySpacedSlot(x, y, from, to, numberOfPoints) : getEquallySpacedSmooth(x, y, from, to, numberOfPoints);\n\n    return reverse ? output.reverse() : output;\n}\n\n/**\n * function that retrieves the getEquallySpacedData with the variant \"smooth\"\n *\n * @param x\n * @param y\n * @param from - Initial point\n * @param to - Final point\n * @param numberOfPoints\n * @returns {Array} - Array of y's equally spaced with the variant \"smooth\"\n */\nfunction getEquallySpacedSmooth(x, y, from, to, numberOfPoints) {\n    var xLength = x.length;\n\n    var step = (to - from) / (numberOfPoints - 1);\n    var halfStep = step / 2;\n\n    var start = from - halfStep;\n    var output = new Array(numberOfPoints);\n\n    var initialOriginalStep = x[1] - x[0];\n    var lastOriginalStep = x[x.length - 1] - x[x.length - 2];\n\n    // Init main variables\n    var min = start;\n    var max = start + step;\n\n    var previousX = Number.MIN_VALUE;\n    var previousY = 0;\n    var nextX = x[0] - initialOriginalStep;\n    var nextY = 0;\n\n    var currentValue = 0;\n    var slope = 0;\n    var intercept = 0;\n    var sumAtMin = 0;\n    var sumAtMax = 0;\n\n    var i = 0; // index of input\n    var j = 0; // index of output\n\n    function getSlope(x0, y0, x1, y1) {\n        return (y1 - y0) / (x1 - x0);\n    }\n\n    main: while(true) {\n        while (nextX - max >= 0) {\n            // no overlap with original point, just consume current value\n            var add = integral(0, max - previousX, slope, previousY);\n            sumAtMax = currentValue + add;\n\n            output[j] = (sumAtMax - sumAtMin) / step;\n            j++;\n\n            if (j === numberOfPoints)\n                break main;\n\n            min = max;\n            max += step;\n            sumAtMin = sumAtMax;\n        }\n\n        if(previousX <= min && min <= nextX) {\n            add = integral(0, min - previousX, slope, previousY);\n            sumAtMin = currentValue + add;\n        }\n\n        currentValue += integral(previousX, nextX, slope, intercept);\n\n        previousX = nextX;\n        previousY = nextY;\n\n        if (i < xLength) {\n            nextX = x[i];\n            nextY = y[i];\n            i++;\n        } else if (i === xLength) {\n            nextX += lastOriginalStep;\n            nextY = 0;\n        }\n        // updating parameters\n        slope = getSlope(previousX, previousY, nextX, nextY);\n        intercept = -slope*previousX + previousY;\n    }\n\n    return output;\n}\n\n/**\n * function that retrieves the getEquallySpacedData with the variant \"slot\"\n *\n * @param x\n * @param y\n * @param from - Initial point\n * @param to - Final point\n * @param numberOfPoints\n * @returns {Array} - Array of y's equally spaced with the variant \"slot\"\n */\nfunction getEquallySpacedSlot(x, y, from, to, numberOfPoints) {\n    var xLength = x.length;\n\n    var step = (to - from) / (numberOfPoints - 1);\n    var halfStep = step / 2;\n    var lastStep = x[x.length - 1] - x[x.length - 2];\n\n    var start = from - halfStep;\n    var output = new Array(numberOfPoints);\n\n    // Init main variables\n    var min = start;\n    var max = start + step;\n\n    var previousX = -Number.MAX_VALUE;\n    var previousY = 0;\n    var nextX = x[0];\n    var nextY = y[0];\n    var frontOutsideSpectra = 0;\n    var backOutsideSpectra = true;\n\n    var currentValue = 0;\n\n    // for slot algorithm\n    var currentPoints = 0;\n\n    var i = 1; // index of input\n    var j = 0; // index of output\n\n    main: while(true) {\n        if (previousX>=nextX) throw (new Error('x must be an increasing serie'));\n        while (previousX - max > 0) {\n            // no overlap with original point, just consume current value\n            if(backOutsideSpectra) {\n                currentPoints++;\n                backOutsideSpectra = false;\n            }\n\n            output[j] = currentPoints <= 0 ? 0 : currentValue / currentPoints;\n            j++;\n\n            if (j === numberOfPoints)\n                break main;\n\n            min = max;\n            max += step;\n            currentValue = 0;\n            currentPoints = 0;\n        }\n\n        if(previousX > min) {\n            currentValue += previousY;\n            currentPoints++;\n        }\n\n        if(previousX === -Number.MAX_VALUE || frontOutsideSpectra > 1)\n            currentPoints--;\n\n        previousX = nextX;\n        previousY = nextY;\n\n        if (i < xLength) {\n            nextX = x[i];\n            nextY = y[i];\n            i++;\n        } else {\n            nextX += lastStep;\n            nextY = 0;\n            frontOutsideSpectra++;\n        }\n    }\n\n    return output;\n}\n/**\n * Function that calculates the integral of the line between two\n * x-coordinates, given the slope and intercept of the line.\n *\n * @param x0\n * @param x1\n * @param slope\n * @param intercept\n * @returns {number} integral value.\n */\nfunction integral(x0, x1, slope, intercept) {\n    return (0.5 * slope * x1 * x1 + intercept * x1) - (0.5 * slope * x0 * x0 + intercept * x0);\n}\n\nexports.getEquallySpacedData = getEquallySpacedData;\nexports.integral = integral;","'use strict';\n\nvar BaseView = require('./base');\nvar util = require('../util');\n\nclass MatrixSubView extends BaseView {\n    constructor(matrix, startRow, endRow, startColumn, endColumn) {\n        util.checkRange(matrix, startRow, endRow, startColumn, endColumn);\n        super(matrix, endRow - startRow + 1, endColumn - startColumn + 1);\n        this.startRow = startRow;\n        this.startColumn = startColumn;\n    }\n\n    set(rowIndex, columnIndex, value) {\n        this.matrix.set(this.startRow + rowIndex, this.startColumn + columnIndex, value);\n        return this;\n    }\n\n    get(rowIndex, columnIndex) {\n        return this.matrix.get(this.startRow + rowIndex, this.startColumn + columnIndex);\n    }\n}\n\nmodule.exports = MatrixSubView;\n"],"sourceRoot":"webpack:///"}